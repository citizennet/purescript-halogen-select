{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Select helps you build selection user interfaces in PureScript with Halogen. You can use it to build dropdowns, typeaheads and autocompletes, date pickers, image pickers, and more, with features like keyboard navigation, accessibility, and state management handled for you. This library takes a unique approach to component design to ensure you can leverage its features without compromising your design in any way. Installation You can use Select in your PureScript project with a compatible package manager. The PureScript community typically leverages psc-package or Bower: 1 2 3 4 5 # Using psc-package $ psc-package install halogen-select # Using Bower $ bower install --save purescript-halogen-select Quick Start If this is your first time using Select , start with the tutorials . I'd recommend starting with the simplest example where you'll learn to make a keyboard-navigable dropdown component: Tip Building a form? Check out Formless , a library for painless forms in Halogen. Don't want to build your own UI components? Check out the Ocelot component library for examples and resources. If this isn't your first time, you'll find value in these resources: The how-to section contains plenty of short guides for common tasks you'll perform using Select . Consider it a grab-bag of useful strategies and examples you can refer to when developing new components. The concepts section contains more detailed explanations on the design of the library. It will help you understand how to make good design choices and make the most of the tools available to you. The reference documentation on Pursuit contains the module documentation and source code. It's a useful reference to verify what functions are available to you. The examples folder on Github contains the working source code for all the components in the tutorials . If you're building a similar component, this code can help you get started. Why Select? Select provides essential behaviors for selection UI as a flexible, extensible Halogen component. But you won't find a single render function in the code. Instead, with a few helper functions, you can write your own State - HTML function however you'd like. You can: Extend the component's functionality by embedding new queries in the HTML Extend the component's data by including as much additional state from the parent as you want (which you can then use in your render function) Leverage the provided features for user interaction, state management, accessibility, and logic Retain complete freedom over the design and aesthetic of your selection component For visual learners I gave a talk at the Los Angeles PureScript meetup in April 2018 about the approach this library takes. It provides an overview of our design approach, including advantages and drawbacks, as well as a simple walkthrough of building a dropdown. No, the man in the preview isn't me -- that's Phil Freeman , the designer of the PureScript programming language.","title":"Home"},{"location":"#welcome","text":"Select helps you build selection user interfaces in PureScript with Halogen. You can use it to build dropdowns, typeaheads and autocompletes, date pickers, image pickers, and more, with features like keyboard navigation, accessibility, and state management handled for you. This library takes a unique approach to component design to ensure you can leverage its features without compromising your design in any way.","title":"Welcome"},{"location":"#installation","text":"You can use Select in your PureScript project with a compatible package manager. The PureScript community typically leverages psc-package or Bower: 1 2 3 4 5 # Using psc-package $ psc-package install halogen-select # Using Bower $ bower install --save purescript-halogen-select","title":"Installation"},{"location":"#quick-start","text":"If this is your first time using Select , start with the tutorials . I'd recommend starting with the simplest example where you'll learn to make a keyboard-navigable dropdown component: Tip Building a form? Check out Formless , a library for painless forms in Halogen. Don't want to build your own UI components? Check out the Ocelot component library for examples and resources. If this isn't your first time, you'll find value in these resources: The how-to section contains plenty of short guides for common tasks you'll perform using Select . Consider it a grab-bag of useful strategies and examples you can refer to when developing new components. The concepts section contains more detailed explanations on the design of the library. It will help you understand how to make good design choices and make the most of the tools available to you. The reference documentation on Pursuit contains the module documentation and source code. It's a useful reference to verify what functions are available to you. The examples folder on Github contains the working source code for all the components in the tutorials . If you're building a similar component, this code can help you get started.","title":"Quick Start"},{"location":"#why-select","text":"Select provides essential behaviors for selection UI as a flexible, extensible Halogen component. But you won't find a single render function in the code. Instead, with a few helper functions, you can write your own State - HTML function however you'd like. You can: Extend the component's functionality by embedding new queries in the HTML Extend the component's data by including as much additional state from the parent as you want (which you can then use in your render function) Leverage the provided features for user interaction, state management, accessibility, and logic Retain complete freedom over the design and aesthetic of your selection component For visual learners I gave a talk at the Los Angeles PureScript meetup in April 2018 about the approach this library takes. It provides an overview of our design approach, including advantages and drawbacks, as well as a simple walkthrough of building a dropdown. No, the man in the preview isn't me -- that's Phil Freeman , the designer of the PureScript programming language.","title":"Why Select?"},{"location":"examples/","text":"Examples You can play around with a few example components here. However, for a much richer set of components with much more functionality, check out the Ocelot design system by CitizenNet . Warning The components on this page function properly, but look horrible while we migrate CSS. Dropdown Dropdowns are a common button-driven input type, especially for navigation. But most custom dropdowns sacrifice usability: unlike browser default dropdowns, you can't type on most custom dropdowns, nor are many built with accessibility in mind. With Select you can easily create rich, usable dropdowns with little code. Curious how to build a dropdown with Select ? Check out the dropdown tutorial . Typeahead / Autocomplete This library was originally designed so that we could build typeaheads with all sorts of custom rendering and functionality. It was frustrating to find solutions that almost worked, but broke down as soon as you needed a moderate level of customization. Building typeaheads with Select is only a little more complex than building dropdowns. Instead of a button as input, you'll use a text input, and you'll be responsible for deciding how to handle user searches. Select handles debouncing user input, keyboard navigation, and more on your behalf. The typeahead below is quite simple; to see examples of more sophisticated typeaheads -- including ones that fetch and display data asynchronously -- check out the Ocelot component library . Curious how to build a typeahead with Select ? Check out the typeahead tutorial .","title":"Examples"},{"location":"examples/#examples","text":"You can play around with a few example components here. However, for a much richer set of components with much more functionality, check out the Ocelot design system by CitizenNet . Warning The components on this page function properly, but look horrible while we migrate CSS.","title":"Examples"},{"location":"examples/#dropdown","text":"Dropdowns are a common button-driven input type, especially for navigation. But most custom dropdowns sacrifice usability: unlike browser default dropdowns, you can't type on most custom dropdowns, nor are many built with accessibility in mind. With Select you can easily create rich, usable dropdowns with little code. Curious how to build a dropdown with Select ? Check out the dropdown tutorial .","title":"Dropdown"},{"location":"examples/#typeahead-autocomplete","text":"This library was originally designed so that we could build typeaheads with all sorts of custom rendering and functionality. It was frustrating to find solutions that almost worked, but broke down as soon as you needed a moderate level of customization. Building typeaheads with Select is only a little more complex than building dropdowns. Instead of a button as input, you'll use a text input, and you'll be responsible for deciding how to handle user searches. Select handles debouncing user input, keyboard navigation, and more on your behalf. The typeahead below is quite simple; to see examples of more sophisticated typeaheads -- including ones that fetch and display data asynchronously -- check out the Ocelot component library . Curious how to build a typeahead with Select ? Check out the typeahead tutorial .","title":"Typeahead / Autocomplete"},{"location":"concepts/understanding-free-queries/","text":"Understanding Free Monad Queries Most of the time Halogen queries look like this: 1 2 3 4 data QueryF ( \u2026 other type arguments omitted \u2026 ) a = ... | SetVisibility Visibility a | GetVisibility ( Visibility - a ) (where QueryF is used directly as the Halogen query functor) This library takes a slightly different approach: the query functor is actually Control . Monad . Free . Free QueryF , the free monad generated by the query functor. This allows queries the full power of monadic (and applicative) composition: sequencing effects, determining control flow based on previous results, and my favorite: doing nothing ( pure unit ). We now define smart query constructors for this Free pattern like so: 1 2 3 4 5 6 7 8 -- | Set the container visibility (`On` or `Off`). setVisibility :: \u2200 o item eff . Visibility - Query o item eff Unit setVisibility v = liftF ( SetVisibility v unit ) -- | Get the container visibility (`On` or `Off`). Most useful when sequenced -- | with other actions. getVisibility :: \u2200 o item eff . Query o item eff Visibility getVisibility = liftF ( GetVisibility id ) Different patterns In the simple cases, the helpers Halogen use to work with raw query constructors are folded into the smart Free query constructors already: H . action ( SetVisibility On ) becomes simply setVisiblity On , and similarly H . request GetVisibility is just getVisibility . This is because these patterns are typically present already smart constructors: setVisibility returns Free QueryF Unit , since it is an action, and getVisibility returns Free QueryF Visibility , since it requests the visibility. This allows for easy composition in do notation: 1 2 3 toggleVisibility = do vis - getVisibility setVisibility ( not vis ) C\u2019est tr\u00e8s facile! Event handlers look a little different. This is one example: 1 2 3 4 HE . onMouseDown \\ ev - Just do Select . preventClick ev Select . select index when doBlur Select . triggerBlur (Of course you may return Nothing if you so wish, but its effect is just like pure unit now.) If you do not need access to the argument ev , Select . always provides a simple shortcut for const Just : 1 HE . onMouseOver $ Select . always $ Select . highlight ( Index index ) Returning non-unit values Use map or $ or pure to return other types of values from a query. So, instead of something like this: 1 2 H . subscribe $ eventSource someEventSource \\ value - Just ( SetVisibility value H . Listening ) Use 1 2 H . subscribe $ eventSource someEventSource \\ value - Just $ setVisibility value $ H . Listening or 1 2 3 4 H . subscribe $ eventSource someEventSource \\ value - Just do setVisibility value pure H . Listening Many thanks to Nicholas Scheel for providing the implementation of QueryF and the documentation above.","title":"Understanding free queries"},{"location":"concepts/understanding-free-queries/#understanding-free-monad-queries","text":"Most of the time Halogen queries look like this: 1 2 3 4 data QueryF ( \u2026 other type arguments omitted \u2026 ) a = ... | SetVisibility Visibility a | GetVisibility ( Visibility - a ) (where QueryF is used directly as the Halogen query functor) This library takes a slightly different approach: the query functor is actually Control . Monad . Free . Free QueryF , the free monad generated by the query functor. This allows queries the full power of monadic (and applicative) composition: sequencing effects, determining control flow based on previous results, and my favorite: doing nothing ( pure unit ). We now define smart query constructors for this Free pattern like so: 1 2 3 4 5 6 7 8 -- | Set the container visibility (`On` or `Off`). setVisibility :: \u2200 o item eff . Visibility - Query o item eff Unit setVisibility v = liftF ( SetVisibility v unit ) -- | Get the container visibility (`On` or `Off`). Most useful when sequenced -- | with other actions. getVisibility :: \u2200 o item eff . Query o item eff Visibility getVisibility = liftF ( GetVisibility id )","title":"Understanding Free Monad Queries"},{"location":"concepts/understanding-free-queries/#different-patterns","text":"In the simple cases, the helpers Halogen use to work with raw query constructors are folded into the smart Free query constructors already: H . action ( SetVisibility On ) becomes simply setVisiblity On , and similarly H . request GetVisibility is just getVisibility . This is because these patterns are typically present already smart constructors: setVisibility returns Free QueryF Unit , since it is an action, and getVisibility returns Free QueryF Visibility , since it requests the visibility. This allows for easy composition in do notation: 1 2 3 toggleVisibility = do vis - getVisibility setVisibility ( not vis ) C\u2019est tr\u00e8s facile! Event handlers look a little different. This is one example: 1 2 3 4 HE . onMouseDown \\ ev - Just do Select . preventClick ev Select . select index when doBlur Select . triggerBlur (Of course you may return Nothing if you so wish, but its effect is just like pure unit now.) If you do not need access to the argument ev , Select . always provides a simple shortcut for const Just : 1 HE . onMouseOver $ Select . always $ Select . highlight ( Index index )","title":"Different patterns"},{"location":"concepts/understanding-free-queries/#returning-non-unit-values","text":"Use map or $ or pure to return other types of values from a query. So, instead of something like this: 1 2 H . subscribe $ eventSource someEventSource \\ value - Just ( SetVisibility value H . Listening ) Use 1 2 H . subscribe $ eventSource someEventSource \\ value - Just $ setVisibility value $ H . Listening or 1 2 3 4 H . subscribe $ eventSource someEventSource \\ value - Just do setVisibility value pure H . Listening Many thanks to Nicholas Scheel for providing the implementation of QueryF and the documentation above.","title":"Returning non-unit values"},{"location":"how-to/embed-parent-queries/","text":"How to Embed Parent Queries One of the most powerful ways to extend Select is to write functionality in your component, triggered by a query, and then embed that query into the Select component.","title":"How to embed parent queries"},{"location":"how-to/embed-parent-queries/#how-to-embed-parent-queries","text":"One of the most powerful ways to extend Select is to write functionality in your component, triggered by a query, and then embed that query into the Select component.","title":"How to Embed Parent Queries"},{"location":"tutorials/dropdown/","text":"Let's Build a Dropdown in PureScript! Dropdowns are among the simplest selection components you will build, but they can be tricky to get right. For example, you'll likely want to ensure that your users can type to highlight close text matches (like when you type \"Ca\" to highlight \"California\" in a state dropdown). You'll want to be accessible to folks using screen readers or keyboard-only navigation, too. And, of course, you'll want to achieve all this without compromising on your design. This tutorial is intended as a beginner-friendly, thorough introduction to Select . We'll build a functional dropdown complete with keyboard navigation. Along the way, we'll learn more about how to work with Halogen components, diagnose type errors, and other common PureScript tasks. Info This tutorial assumes you've followed the steps in the Project Setup section. While not necessary, this code is tested with those steps in mind. It also assumes familiarity with the Halogen framework. If you need a refresher, try the official Halogen guide or the whirlwind tour of our starter component. If you are already an intermediate or advanced PureScript developer, then this tutorial will read slowly for you. Feel free to skim, get the gist of how the library works, and then move on to the faster-paced and more advanced typeahead tutorial . Your code should work at the end of every step. If you run into issues or your code doesn't compile, please come visit us on the PureScript user forum or the #fpchat Slack channel . We're going to build a dropdown that is functionally equivalent this one: Basic Setup Let's get something on the screen! The simplest sort of dropdown has a button that can toggle a menu open or closed, a list of items that can be selected from that menu, and zero, one, or more selected items. For our dropdown we'll assume that you can select at most one item, and that selecting an item will replace the text on the button with that item. Rendering a button and items We'll start by rendering the button and the items. At this point our render function contains only an empty div, so let's fill in the rest of the HTML we need: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [ HH . h1_ [ HH . text Dropdown ] , HH . button_ [ HH . text Click me to view some items ] , HH . ul_ [ HH . li_ [ HH . text Item 1 ] , HH . li_ [ HH . text Item 2 ] ] ] Make sure to compile this code and view the new output! You should see a header, a button, and two items in the list. After each step, make sure your code still compiles. A better State type It's already clear we're going to need more than Unit for our State type. We at least need to know three things: If the menu is toggled on or off The currently-selected item (if there is one) The list of items available for selection We can represent each of these with simple types in our state: 1 2 3 4 5 type State = { isOpen :: Boolean , selectedItem :: Maybe String , availableItems :: Array String } Now that our state contains these three fields, we need to update our initialState function to produce the right type of values: 1 2 3 4 5 6 7 8 9 10 initialState :: Input - State initialState = const { isOpen : false , selectedItem : Nothing , availableItems : [ Item One , Item Two , Item Three ] } Finally, lets update our render function to leverage the information now contained in State . If there's a selected item, that will be the button's text; if not, we'll fall back to a default message. If the menu is open, we'll list out the available items for selection. For code clarity, we'll also break out the dropdown into its own helper function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import Data.Maybe ( fromMaybe ) render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [ HH . h1_ [ HH . text Dropdown ] , dropdown st ] dropdown :: State - H . ParentHTML Query ChildQuery ChildSlot m dropdown = HH . div_ [ HH . button_ [ HH . text $ fromMaybe Click me to view some items st . selectedItem ] , if st . isOpen then HH . ul_ $ ( \\ item - HH . li_ [ HH . text item ]) $ st . availableItems else HH . text ] Tip Since the dropdown has no behavior yet, try changing the initialState to set isOpen to true to verify your items are in fact being rendered out to the page. It ain't pretty, but at this point we've got all the rendering we need for a basic dropdown! The next step is to actually wire in some behavior. Integrating the component Let's integrate the Select component! In just a few steps, we'll turn our simple render function into a fully-functioning dropdown with keyboard navigation, toggling, debounced type-to-search, and several other features. On building components with Select The key idea behind the Select library is to provide behaviors, not rendering . The core component the library exposes doesn't have a render function at all! Of course, all Halogen components require a render function to work, and Select is no different. You are expected to provide that render function. Why? When you write the render function, not the library, you get to decide exactly what your component will look and feel like. You can also control what queries to trigger from HTML and when, effectively allowing you to control the behavior of the component without configuration . You can even extend it with new behavior and new state by using information from your parent component. The end result is a much smaller library component with a lot more flexibility and power for you. We just wrote the rendering we need for an (admittedly ugly) dropdown. The render function we just wrote can actually serve almost as-is as the render function for Select ! All we have to do is mount the Select component, make a few tweaks to our render code, and then pass in a little configuration information. Let's do that next. Importing the Select component The first thing we'll do is bring in the Select library in the first place. 1 2 import Select as Select import Select.Setters as Setters Tip You can always view the module documentation for Select on Pursuit or the source code on GitHub . This is useful when integrating with third-party components so that you can check out the Input , State , Query , and Message types. Next, we need to update our ChildSlot and ChildQuery types. We're only going to have one dropdown so we can leave the child slot as Unit ; we do need to add the Select component's query type to our ChildQuery synonym, however. This code, unfortunately, won't work: 1 2 3 4 5 6 7 type ChildQuery = Select . Query Error found : Type synonym Select . Query is partially applied . Type synonyms must be applied to all of their type arguments . in type synonym ChildQuery The compiler has noticed that ChildQuery , a type synonym, is partially applied. That's because Select . Query , itself a type synonym, takes several arguments as described in the module documentation on Pursuit . Let's walk through each one: 1 type ChildQuery o item = Select . Query o item o is your query type. Remember how you can embed your own queries into Select , and in that way extend the component's functionality? This is how. So we can fill in the first argument: 1 type ChildQuery item = Select . Query Query item item is the type of whatever items you want to be selectable. Commonly these are strings, but can also be custom data types. Later on, in the typeahead tutorial , we'll see how powerful custom data types can be for rendering purposes. For our simple dropdown we'll simply specialize this to String : 1 type ChildQuery = Select . Query Query String Now that Select has been imported and we've updated our ChildQuery and ChildSlot types to support it, we can worry about what to do when we receive a message from the component. Mounting the component We're finally ready to mount the Select component. Mounting any component in Halogen requires supplying a slot value, the component itself, the component's input, and the component's handler. We can put together all of these except for the input, which we haven't prepared yet. Let's stub out our render function in preparation: 1 2 3 4 5 6 7 8 9 import Halogen.HTML.Events as HE render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [ HH . h1_ [ HH . text Dropdown ] , HH . slot unit Select . component ? input ( HE . input const Nothing ) ] With that out of the way, we can turn to filling in our component's input type. We can either look at the module documentation for Select.Input or look at the type error that resulted from our typed hole, ?input . Both will tell us that we need to provide a value of this type: 1 2 3 4 5 6 7 type Input o item = { inputType :: InputType , items :: Array item , initialSearch :: Maybe String , debounceTime :: Maybe Milliseconds , render :: State item - ComponentHTML o item } Let's build this up, step by step. First, we see we have to provide an InputType . This is described in the module documentation: 1 2 3 4 5 6 -- | Text-driven inputs will operate like a normal search-driven selection component. -- | Toggle-driven inputs will capture key streams and debounce in reverse (only notify -- | about searches when time has expired). data InputType = TextInput | Toggle We don't have any text input for our dropdown -- its a button -- so we'll go with the Toggle constructor. 1 2 3 4 5 selectInput :: Select . Input Query String selectInput = { inputType : Select . Toggle , ... } Next, we're expected to provide an array of items. Fortunately we already have those in our State . We can just send those items directly into the input. 1 2 3 4 selectInput = { ... , items : st . availableItems } Next, we're expected to provide an initial search. This would be more useful if we had a text input, but for our dropdown, we'll start off with no initial search. 1 2 3 4 selectInput = { ... , initialSearch : Nothing } What about a debounce time? For toggle-driven components, this is how long to aggregate key presses before the user's typing should affect the list of items. For search-driven components, this is how long to delay before raising a message with the new search. For our dropdown, we don't care: 1 2 3 4 selectInput = { ... , debounceTime : Nothing } Finally, we're expected to provide a render function to the component. Ah ha! We've actually already written a render function for a dropdown -- it's just that the type is wrong. Adapting the render function for Select Let's look at the types side-by-side: 1 2 3 4 5 6 7 8 9 10 11 Select . render :: Select . State item - Select . ComponentHTML o item dropdown :: State - H . ParentHTML Query ChildQuery ChildSlot m dropdown st = HH . div_ [ HH . button_ [ HH . text $ fromMaybe Click me to view some items st . selectedItem ] , if st . isOpen then HH . ul_ $ ( \\ item - HH . li_ [ HH . text item ]) $ st . availableItems else HH . text ] From this, we can see that we need to use the state type from Select to drive our render function, not the state from our parent component. Will our function still work? Let's look at Select 's state type in the module documentation to see what we have available: 1 2 3 4 5 6 7 8 9 10 11 type State item = { inputType :: InputType , search :: String , debounceTime :: Milliseconds , debouncer :: Maybe Debouncer , inputElement :: Maybe HTMLElement , items :: Array item , visibility :: Visibility , highlightedIndex :: Maybe Int , lastIndex :: Int } That's a lot of stuff! We have some of the data we need in Select 's state -- we have our list of items and whether the menu is open or closed. We even got new information, like which item is highlighted. But we're missing something crucial: which item is selected. As a general rule, Select does not manage selections on your behalf. You are expected to decide what you want to happen when an item is selected and to store the selections yourself. What can we do? We don't have all the information we need to write this function. Or do we? In fact, so long as we write the Select render function within the where clause of the parent component's render function , we have access to the parent's state! Let's give it a shot. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 render parentState = HH . div_ [ HH . h1_ [ HH . text Dropdown ] , HH . slot unit Select . component ? input ( HE . input const Nothing ) ] where dropdown :: Select . State String - Select . ComponentHTML Query String dropdown childState = HH . div_ [ HH . button_ [ HH . text $ fromMaybe Click me to view some items parentState . selectedItem ] , if childState . visibility == Select . On then HH . ul_ $ ( \\ item - HH . li_ [ HH . text item ]) $ childState . items else HH . text ] It works! Even better, we no longer have to manage things like openState in the parent anymore. Finally, now that we have the render function we need, we can finally finish our component's input type: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 render :: State - H . ParentHTML Query ChildQuery ChildSlot m render parentState = HH . div_ [ HH . h1_ [ HH . text Dropdown ] , HH . slot unit Select . component selectInput ( HE . input const Nothing ) ] where selectInput :: Select . Input Query String selectInput = { inputType : Select . Toggle , items : parentState . availableItems , initialSearch : Nothing , debounceTime : Nothing , render : dropdown } dropdown = ... Integrating Behavior Everything up to this point has been standard Halogen except for writing the child component's render function. At this point, the Select component is running -- good work! However, it's not yet doing anything. It's now time to turn your static HTML into a fully-functioning dropdown. Attaching behavior to Select Select works by using a few helper functions that attach at critical points in your render function. The library assumes very little about what your rendering looks like, except that there at least exists: One or more items that can be selected An element that contains those items A focusable element that can be used to toggle visibility and capture keystrokes Accordingly, you'll need to use three helper functions, each exported by the Select.Setters module: setItemProps setContainerProps setToggleProps (for toggle-driven input) setInputProps (for text-driven input) Each of these functions should be used on the property array for the relevant element in your HTML. Let's walk through each one using our built render function. First, let's augment our individual items. setItemProps takes an index and some properties and outputs some new properties, which include all sorts of event handlers necessary for keyboard events and click events to work. In order to provide it with the index it needs, we'll use the mapWithIndex function from Data . Array . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import Data.Array ( mapWithIndex ) dropdown childState = HH . div_ [ HH . button_ [ HH . text $ fromMaybe Click me to view some items parentState . selectedItem ] , case childState . visibility of Select . Off - HH . text Select . On - HH . ul [] $ mapWithIndex ( \\ ix item - HH . li ( Setters . setItemProps ix [] ) [ HH . text item ]) childState . items ] Next, we'll move to the element that contains the items. The setContainerProps function takes and returns some properties, attaching all the behavior the library needs. We'll use this on the parent element, ul : 1 2 3 4 5 6 7 8 9 10 11 12 dropdown childState = HH . div_ [ HH . button_ [ HH . text $ fromMaybe Click me to view some items parentState . selectedItem ] , case childState . visibility of Select . Off - HH . text Select . On - HH . ul ( Setters . setContainerProps [] ) $ mapWithIndex ( \\ ix item - HH . li ( Setters . setItemProps ix [] ) [ HH . text item ]) childState . items ] Finally, we can make sure that our button toggles the menu on and off, captures keyboard events, can be tabbed to, and all sorts of other stuff with the setToggleProps function. 1 2 3 4 5 6 7 8 9 10 11 12 13 dropdown childState = HH . div_ [ HH . button ( Setters . setToggleProps [] ) [ HH . text $ fromMaybe Click me to view some items parentState . selectedItem ] , case childState . visibility of Select . Off - HH . text Select . On - HH . ul [] $ mapWithIndex ( \\ ix item - HH . li ( Setters . setItemProps ix [] ) [ HH . text item ]) childState . items ] Whew! Your rendering code now contains everything it needs to provide a keyboard-accessible dropdown. If you open this up in the browser and click around, you'll notice it's properly toggling and can be tabbed to. Let's make one last improvement. When you use your arrow keys on the dropdown, the highlighted index is changing, but since we didn't provide any CSS we can't see it. Let's add some bare-bones styling so we can watch the highlights: 1 2 3 4 5 6 7 8 9 10 11 12 13 import Halogen.HTML.Properties as HP Select . On - HH . ul ( Setters . setContainerProps [] ) $ mapWithIndex ( \\ ix item - HH . li ( Setters . setItemProps ix $ case Just ix == childState . highlightedIndex of true - [ HP . attr ( HH . AttrName style ) color: red; ] _ - [] ) [ HH . text item ] ) childState . items There we go! Try toggling the menu on and off, using your arrow, enter, and escape keys, and so on. It works! ...almost. Alas, we aren't doing anything when the user makes a selection. Select is attempting to notify us that a selection occurred, but we never provided a handler. Let's fix that now. Handling messages from Select When you add a new child component you invariably need to add a handler for its Message type. What should the parent do when something important has occurred in the child? To handle messages, add a new constructor to your query algebra that takes the child's Message type as an argument: 1 2 3 data Query a = NoOp a | HandleSelect Select . Message a Ah -- this won't compile! 1 2 3 4 5 6 7 8 9 Error found in module Component : Could not match kind ( Type - Type ) - Type - Type with kind Type in type constructor Query This looks similar to the type error we got when we tried to just use Select.Query in a type synonym. We need to provide a Type to HandleSelect , but Select . Message is still awaiting 2 arguments, the first of which is itself awaiting an argument! Let's go look at the module documentation for Select.Message . 1 data Message o item We've seen both of these arguments before in the component's query type, so we should fill them in with the same values. o is our parent component query type, and item is a String : 1 2 3 data Query a = NoOp a | HandleSelect ( Select . Message Query String ) a As soon as you save and rebuild you'll see another compiler error! 1 2 3 4 5 6 7 8 Error found in module Component A case expression could not be determined to cover all inputs . The following additional cases are required to cover all inputs : ( HandleSelect _ _ ) in value declaration component This time it's because we've added a new query, but we never updated our eval function to describe what should happen when the query is triggered. What should we actually do when a message comes up from the child component? Tip You'll often see type errors that end in \"... value declaration component.\" when the error occurred in any of the functions in the where clause for the component. It can be annoying to track down where the error actually is in your code. One way to help track these down is to move your code out of the where block and into the module level temporarily so the compiler can identify which particular function is causing the issue. There are four possible sub-cases that we need to handle, each described in the module documentation: 1 2 3 4 5 data Message o item = Searched String | Selected item | VisibilityChanged Visibility | Emit ( o Unit ) Let's stub out each of these cases and then decide what to do with them: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 eval :: Query ~ H . ParentDSL State Query ( ChildQuery eff ) ChildSlot Message m eval = case _ of NoOp next - pure next HandleSelect message next - case message of Select . Searched string - pure next Select . Selected item - pure next Select . VisibilityChanged vis - pure next Select . Emit query - pure next Let's take these case-by-case. What should we do when the user has searched something on our dropdown? This is just a simple list of items, so we'll simply ignore their search. We can leave this as pure next . What should we do when the user has selected an item? Ah! This is more interesting. We want to set their item as the currently-selected one, and then we want to remove it from the available items list. Once we've removed it from the available items, we'll update Select with its new items to display and we'll toggle it off. We can use difference from Data . Array to filter out the selected item from the overall list of items. This is a common pattern in Select : the parent holds the immutable list of all possible items, and Select receives some subset of those items at each render. You might use the user's search to filter out items in a typeahead, for example, or only load 50 results at a time into a dropdown. 1 2 3 4 5 6 7 import Data.Array ( difference ) Select . Selected item - do st - H . get _ - H . query unit $ Select . setVisibility Select . Off _ - H . query unit $ Select . replaceItems $ difference st . availableItems [ item ] H . modify _ { selectedItem = Just item } What should we do when the dropdown's visibility has changed? This can often be useful to run validation, but for our dropdown, we don't care what its visibility is. We can leave this as pure next . Finally, what should we do when the child component raises its Emit message? What does this even mean? Emit exists so you can embed your own queries into Select and extend its behavior. Since the message contains one of your own queries, all you have to do is evaluate it: you can call eval recursively to run your query. You can think of Emit as notifying you that the query you embedded is ready to run. 1 2 3 Select . Emit query - do eval query pure next Nice and simple! While you may write all kinds of logic for the other messages raised by Select , you'll always write this same code for the Emit message. Conclusion Congratulations! You have successfully built a keyboard-navigable dropdown using Select . You integrated the library, wrote your own render function, and then augmented it with helper functions from the library. Then, you handled the output messages and sent queries to update the component's state. You've done quite a lot of work! Tip Did you notice anything you would improve about this tutorial or the Select library? I'd love to hear about it! Feel free to reach out on the functional programming Slack or on the PureScript user forum . If you found a bug or would like to make an improvement, please open an issue or pull request on the library. Next Steps This tutorial was a slow, thorough introduction to the Select library. But we've only scratched the surface of what you can do with it. I'd recommend continuing on to the faster-paced and more advanced typeahead tutorial . Source Code If you'd like to use this component as a starting point from which to build your own, feel free to copy/paste the source code below. Full source code for the tutorial 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 module Component where import Prelude import Effect.Aff.Class ( class MonadAff ) import Data.Array ( difference , mapWithIndex ) import Data.Maybe ( Maybe ( .. ), fromMaybe ) import Halogen as H import Halogen.HTML as HH import Halogen.HTML.Events as HE import Halogen.HTML.Properties as HP import Select as Select import Select.Setters as Setters data Query a = HandleSelect ( Select . Message Query String ) a type State = { isOpen :: Boolean , selectedItem :: Maybe String , availableItems :: Array String } type Input = Unit type Message = Void type ChildSlot = Unit type ChildQuery = Select . Query Query String component :: \u2200 m . MonadAff m = H . Component HH . HTML Query Input Message m component = H . parentComponent { initialState , render , eval , receiver : const Nothing } where initialState :: Input - State initialState = const { isOpen : false , selectedItem : Nothing , availableItems : [ Item One , Item Two , Item Three ] } render :: State - H . ParentHTML Query ChildQuery ChildSlot m render parentState = HH . div_ [ HH . h1_ [ HH . text Dropdown ] , HH . slot unit Select . component selectInput ( HE . input HandleSelect ) ] where selectInput :: Select . Input Query String selectInput = { inputType : Select . Toggle , items : parentState . availableItems , initialSearch : Nothing , debounceTime : Nothing , render : dropdown } dropdown :: Select . State String - Select . ComponentHTML Query String dropdown childState = HH . div_ [ HH . button ( Setters . setToggleProps [] ) [ HH . text $ fromMaybe Click me to view some items parentState . selectedItem ] , case childState . visibility of Select . Off - HH . text Select . On - HH . ul ( Setters . setContainerProps [] ) $ mapWithIndex ( \\ ix item - HH . li ( Setters . setItemProps ix $ case Just ix == childState . highlightedIndex of true - [ HP . attr ( HH . AttrName style ) color: red; ] _ - [] ) [ HH . text item ] ) childState . items ] eval :: Query ~ H . ParentDSL State Query ChildQuery ChildSlot Message m eval = case _ of HandleSelect message next - case message of Select . Searched string - pure next Select . Selected item - do st - H . get _ - H . query unit $ Select . setVisibility Select . Off _ - H . query unit $ Select . replaceItems $ difference st . availableItems [ item ] H . modify _ { selectedItem = Just item } pure next Select . VisibilityChanged vis - pure next Select . Emit query - do eval query pure next","title":"Build a dropdown"},{"location":"tutorials/dropdown/#lets-build-a-dropdown-in-purescript","text":"Dropdowns are among the simplest selection components you will build, but they can be tricky to get right. For example, you'll likely want to ensure that your users can type to highlight close text matches (like when you type \"Ca\" to highlight \"California\" in a state dropdown). You'll want to be accessible to folks using screen readers or keyboard-only navigation, too. And, of course, you'll want to achieve all this without compromising on your design. This tutorial is intended as a beginner-friendly, thorough introduction to Select . We'll build a functional dropdown complete with keyboard navigation. Along the way, we'll learn more about how to work with Halogen components, diagnose type errors, and other common PureScript tasks. Info This tutorial assumes you've followed the steps in the Project Setup section. While not necessary, this code is tested with those steps in mind. It also assumes familiarity with the Halogen framework. If you need a refresher, try the official Halogen guide or the whirlwind tour of our starter component. If you are already an intermediate or advanced PureScript developer, then this tutorial will read slowly for you. Feel free to skim, get the gist of how the library works, and then move on to the faster-paced and more advanced typeahead tutorial . Your code should work at the end of every step. If you run into issues or your code doesn't compile, please come visit us on the PureScript user forum or the #fpchat Slack channel . We're going to build a dropdown that is functionally equivalent this one:","title":"Let's Build a Dropdown in PureScript!"},{"location":"tutorials/dropdown/#basic-setup","text":"Let's get something on the screen! The simplest sort of dropdown has a button that can toggle a menu open or closed, a list of items that can be selected from that menu, and zero, one, or more selected items. For our dropdown we'll assume that you can select at most one item, and that selecting an item will replace the text on the button with that item.","title":"Basic Setup"},{"location":"tutorials/dropdown/#rendering-a-button-and-items","text":"We'll start by rendering the button and the items. At this point our render function contains only an empty div, so let's fill in the rest of the HTML we need: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [ HH . h1_ [ HH . text Dropdown ] , HH . button_ [ HH . text Click me to view some items ] , HH . ul_ [ HH . li_ [ HH . text Item 1 ] , HH . li_ [ HH . text Item 2 ] ] ] Make sure to compile this code and view the new output! You should see a header, a button, and two items in the list. After each step, make sure your code still compiles.","title":"Rendering a button and items"},{"location":"tutorials/dropdown/#a-better-state-type","text":"It's already clear we're going to need more than Unit for our State type. We at least need to know three things: If the menu is toggled on or off The currently-selected item (if there is one) The list of items available for selection We can represent each of these with simple types in our state: 1 2 3 4 5 type State = { isOpen :: Boolean , selectedItem :: Maybe String , availableItems :: Array String } Now that our state contains these three fields, we need to update our initialState function to produce the right type of values: 1 2 3 4 5 6 7 8 9 10 initialState :: Input - State initialState = const { isOpen : false , selectedItem : Nothing , availableItems : [ Item One , Item Two , Item Three ] } Finally, lets update our render function to leverage the information now contained in State . If there's a selected item, that will be the button's text; if not, we'll fall back to a default message. If the menu is open, we'll list out the available items for selection. For code clarity, we'll also break out the dropdown into its own helper function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import Data.Maybe ( fromMaybe ) render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [ HH . h1_ [ HH . text Dropdown ] , dropdown st ] dropdown :: State - H . ParentHTML Query ChildQuery ChildSlot m dropdown = HH . div_ [ HH . button_ [ HH . text $ fromMaybe Click me to view some items st . selectedItem ] , if st . isOpen then HH . ul_ $ ( \\ item - HH . li_ [ HH . text item ]) $ st . availableItems else HH . text ] Tip Since the dropdown has no behavior yet, try changing the initialState to set isOpen to true to verify your items are in fact being rendered out to the page. It ain't pretty, but at this point we've got all the rendering we need for a basic dropdown! The next step is to actually wire in some behavior.","title":"A better State type"},{"location":"tutorials/dropdown/#integrating-the-component","text":"Let's integrate the Select component! In just a few steps, we'll turn our simple render function into a fully-functioning dropdown with keyboard navigation, toggling, debounced type-to-search, and several other features.","title":"Integrating the component"},{"location":"tutorials/dropdown/#on-building-components-with-select","text":"The key idea behind the Select library is to provide behaviors, not rendering . The core component the library exposes doesn't have a render function at all! Of course, all Halogen components require a render function to work, and Select is no different. You are expected to provide that render function. Why? When you write the render function, not the library, you get to decide exactly what your component will look and feel like. You can also control what queries to trigger from HTML and when, effectively allowing you to control the behavior of the component without configuration . You can even extend it with new behavior and new state by using information from your parent component. The end result is a much smaller library component with a lot more flexibility and power for you. We just wrote the rendering we need for an (admittedly ugly) dropdown. The render function we just wrote can actually serve almost as-is as the render function for Select ! All we have to do is mount the Select component, make a few tweaks to our render code, and then pass in a little configuration information. Let's do that next.","title":"On building components with Select"},{"location":"tutorials/dropdown/#importing-the-select-component","text":"The first thing we'll do is bring in the Select library in the first place. 1 2 import Select as Select import Select.Setters as Setters Tip You can always view the module documentation for Select on Pursuit or the source code on GitHub . This is useful when integrating with third-party components so that you can check out the Input , State , Query , and Message types. Next, we need to update our ChildSlot and ChildQuery types. We're only going to have one dropdown so we can leave the child slot as Unit ; we do need to add the Select component's query type to our ChildQuery synonym, however. This code, unfortunately, won't work: 1 2 3 4 5 6 7 type ChildQuery = Select . Query Error found : Type synonym Select . Query is partially applied . Type synonyms must be applied to all of their type arguments . in type synonym ChildQuery The compiler has noticed that ChildQuery , a type synonym, is partially applied. That's because Select . Query , itself a type synonym, takes several arguments as described in the module documentation on Pursuit . Let's walk through each one: 1 type ChildQuery o item = Select . Query o item o is your query type. Remember how you can embed your own queries into Select , and in that way extend the component's functionality? This is how. So we can fill in the first argument: 1 type ChildQuery item = Select . Query Query item item is the type of whatever items you want to be selectable. Commonly these are strings, but can also be custom data types. Later on, in the typeahead tutorial , we'll see how powerful custom data types can be for rendering purposes. For our simple dropdown we'll simply specialize this to String : 1 type ChildQuery = Select . Query Query String Now that Select has been imported and we've updated our ChildQuery and ChildSlot types to support it, we can worry about what to do when we receive a message from the component.","title":"Importing the Select component"},{"location":"tutorials/dropdown/#mounting-the-component","text":"We're finally ready to mount the Select component. Mounting any component in Halogen requires supplying a slot value, the component itself, the component's input, and the component's handler. We can put together all of these except for the input, which we haven't prepared yet. Let's stub out our render function in preparation: 1 2 3 4 5 6 7 8 9 import Halogen.HTML.Events as HE render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [ HH . h1_ [ HH . text Dropdown ] , HH . slot unit Select . component ? input ( HE . input const Nothing ) ] With that out of the way, we can turn to filling in our component's input type. We can either look at the module documentation for Select.Input or look at the type error that resulted from our typed hole, ?input . Both will tell us that we need to provide a value of this type: 1 2 3 4 5 6 7 type Input o item = { inputType :: InputType , items :: Array item , initialSearch :: Maybe String , debounceTime :: Maybe Milliseconds , render :: State item - ComponentHTML o item } Let's build this up, step by step. First, we see we have to provide an InputType . This is described in the module documentation: 1 2 3 4 5 6 -- | Text-driven inputs will operate like a normal search-driven selection component. -- | Toggle-driven inputs will capture key streams and debounce in reverse (only notify -- | about searches when time has expired). data InputType = TextInput | Toggle We don't have any text input for our dropdown -- its a button -- so we'll go with the Toggle constructor. 1 2 3 4 5 selectInput :: Select . Input Query String selectInput = { inputType : Select . Toggle , ... } Next, we're expected to provide an array of items. Fortunately we already have those in our State . We can just send those items directly into the input. 1 2 3 4 selectInput = { ... , items : st . availableItems } Next, we're expected to provide an initial search. This would be more useful if we had a text input, but for our dropdown, we'll start off with no initial search. 1 2 3 4 selectInput = { ... , initialSearch : Nothing } What about a debounce time? For toggle-driven components, this is how long to aggregate key presses before the user's typing should affect the list of items. For search-driven components, this is how long to delay before raising a message with the new search. For our dropdown, we don't care: 1 2 3 4 selectInput = { ... , debounceTime : Nothing } Finally, we're expected to provide a render function to the component. Ah ha! We've actually already written a render function for a dropdown -- it's just that the type is wrong.","title":"Mounting the component"},{"location":"tutorials/dropdown/#adapting-the-render-function-for-select","text":"Let's look at the types side-by-side: 1 2 3 4 5 6 7 8 9 10 11 Select . render :: Select . State item - Select . ComponentHTML o item dropdown :: State - H . ParentHTML Query ChildQuery ChildSlot m dropdown st = HH . div_ [ HH . button_ [ HH . text $ fromMaybe Click me to view some items st . selectedItem ] , if st . isOpen then HH . ul_ $ ( \\ item - HH . li_ [ HH . text item ]) $ st . availableItems else HH . text ] From this, we can see that we need to use the state type from Select to drive our render function, not the state from our parent component. Will our function still work? Let's look at Select 's state type in the module documentation to see what we have available: 1 2 3 4 5 6 7 8 9 10 11 type State item = { inputType :: InputType , search :: String , debounceTime :: Milliseconds , debouncer :: Maybe Debouncer , inputElement :: Maybe HTMLElement , items :: Array item , visibility :: Visibility , highlightedIndex :: Maybe Int , lastIndex :: Int } That's a lot of stuff! We have some of the data we need in Select 's state -- we have our list of items and whether the menu is open or closed. We even got new information, like which item is highlighted. But we're missing something crucial: which item is selected. As a general rule, Select does not manage selections on your behalf. You are expected to decide what you want to happen when an item is selected and to store the selections yourself. What can we do? We don't have all the information we need to write this function. Or do we? In fact, so long as we write the Select render function within the where clause of the parent component's render function , we have access to the parent's state! Let's give it a shot. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 render parentState = HH . div_ [ HH . h1_ [ HH . text Dropdown ] , HH . slot unit Select . component ? input ( HE . input const Nothing ) ] where dropdown :: Select . State String - Select . ComponentHTML Query String dropdown childState = HH . div_ [ HH . button_ [ HH . text $ fromMaybe Click me to view some items parentState . selectedItem ] , if childState . visibility == Select . On then HH . ul_ $ ( \\ item - HH . li_ [ HH . text item ]) $ childState . items else HH . text ] It works! Even better, we no longer have to manage things like openState in the parent anymore. Finally, now that we have the render function we need, we can finally finish our component's input type: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 render :: State - H . ParentHTML Query ChildQuery ChildSlot m render parentState = HH . div_ [ HH . h1_ [ HH . text Dropdown ] , HH . slot unit Select . component selectInput ( HE . input const Nothing ) ] where selectInput :: Select . Input Query String selectInput = { inputType : Select . Toggle , items : parentState . availableItems , initialSearch : Nothing , debounceTime : Nothing , render : dropdown } dropdown = ...","title":"Adapting the render function for Select"},{"location":"tutorials/dropdown/#integrating-behavior","text":"Everything up to this point has been standard Halogen except for writing the child component's render function. At this point, the Select component is running -- good work! However, it's not yet doing anything. It's now time to turn your static HTML into a fully-functioning dropdown.","title":"Integrating Behavior"},{"location":"tutorials/dropdown/#attaching-behavior-to-select","text":"Select works by using a few helper functions that attach at critical points in your render function. The library assumes very little about what your rendering looks like, except that there at least exists: One or more items that can be selected An element that contains those items A focusable element that can be used to toggle visibility and capture keystrokes Accordingly, you'll need to use three helper functions, each exported by the Select.Setters module: setItemProps setContainerProps setToggleProps (for toggle-driven input) setInputProps (for text-driven input) Each of these functions should be used on the property array for the relevant element in your HTML. Let's walk through each one using our built render function. First, let's augment our individual items. setItemProps takes an index and some properties and outputs some new properties, which include all sorts of event handlers necessary for keyboard events and click events to work. In order to provide it with the index it needs, we'll use the mapWithIndex function from Data . Array . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import Data.Array ( mapWithIndex ) dropdown childState = HH . div_ [ HH . button_ [ HH . text $ fromMaybe Click me to view some items parentState . selectedItem ] , case childState . visibility of Select . Off - HH . text Select . On - HH . ul [] $ mapWithIndex ( \\ ix item - HH . li ( Setters . setItemProps ix [] ) [ HH . text item ]) childState . items ] Next, we'll move to the element that contains the items. The setContainerProps function takes and returns some properties, attaching all the behavior the library needs. We'll use this on the parent element, ul : 1 2 3 4 5 6 7 8 9 10 11 12 dropdown childState = HH . div_ [ HH . button_ [ HH . text $ fromMaybe Click me to view some items parentState . selectedItem ] , case childState . visibility of Select . Off - HH . text Select . On - HH . ul ( Setters . setContainerProps [] ) $ mapWithIndex ( \\ ix item - HH . li ( Setters . setItemProps ix [] ) [ HH . text item ]) childState . items ] Finally, we can make sure that our button toggles the menu on and off, captures keyboard events, can be tabbed to, and all sorts of other stuff with the setToggleProps function. 1 2 3 4 5 6 7 8 9 10 11 12 13 dropdown childState = HH . div_ [ HH . button ( Setters . setToggleProps [] ) [ HH . text $ fromMaybe Click me to view some items parentState . selectedItem ] , case childState . visibility of Select . Off - HH . text Select . On - HH . ul [] $ mapWithIndex ( \\ ix item - HH . li ( Setters . setItemProps ix [] ) [ HH . text item ]) childState . items ] Whew! Your rendering code now contains everything it needs to provide a keyboard-accessible dropdown. If you open this up in the browser and click around, you'll notice it's properly toggling and can be tabbed to. Let's make one last improvement. When you use your arrow keys on the dropdown, the highlighted index is changing, but since we didn't provide any CSS we can't see it. Let's add some bare-bones styling so we can watch the highlights: 1 2 3 4 5 6 7 8 9 10 11 12 13 import Halogen.HTML.Properties as HP Select . On - HH . ul ( Setters . setContainerProps [] ) $ mapWithIndex ( \\ ix item - HH . li ( Setters . setItemProps ix $ case Just ix == childState . highlightedIndex of true - [ HP . attr ( HH . AttrName style ) color: red; ] _ - [] ) [ HH . text item ] ) childState . items There we go! Try toggling the menu on and off, using your arrow, enter, and escape keys, and so on. It works! ...almost. Alas, we aren't doing anything when the user makes a selection. Select is attempting to notify us that a selection occurred, but we never provided a handler. Let's fix that now.","title":"Attaching behavior to Select"},{"location":"tutorials/dropdown/#handling-messages-from-select","text":"When you add a new child component you invariably need to add a handler for its Message type. What should the parent do when something important has occurred in the child? To handle messages, add a new constructor to your query algebra that takes the child's Message type as an argument: 1 2 3 data Query a = NoOp a | HandleSelect Select . Message a Ah -- this won't compile! 1 2 3 4 5 6 7 8 9 Error found in module Component : Could not match kind ( Type - Type ) - Type - Type with kind Type in type constructor Query This looks similar to the type error we got when we tried to just use Select.Query in a type synonym. We need to provide a Type to HandleSelect , but Select . Message is still awaiting 2 arguments, the first of which is itself awaiting an argument! Let's go look at the module documentation for Select.Message . 1 data Message o item We've seen both of these arguments before in the component's query type, so we should fill them in with the same values. o is our parent component query type, and item is a String : 1 2 3 data Query a = NoOp a | HandleSelect ( Select . Message Query String ) a As soon as you save and rebuild you'll see another compiler error! 1 2 3 4 5 6 7 8 Error found in module Component A case expression could not be determined to cover all inputs . The following additional cases are required to cover all inputs : ( HandleSelect _ _ ) in value declaration component This time it's because we've added a new query, but we never updated our eval function to describe what should happen when the query is triggered. What should we actually do when a message comes up from the child component? Tip You'll often see type errors that end in \"... value declaration component.\" when the error occurred in any of the functions in the where clause for the component. It can be annoying to track down where the error actually is in your code. One way to help track these down is to move your code out of the where block and into the module level temporarily so the compiler can identify which particular function is causing the issue. There are four possible sub-cases that we need to handle, each described in the module documentation: 1 2 3 4 5 data Message o item = Searched String | Selected item | VisibilityChanged Visibility | Emit ( o Unit ) Let's stub out each of these cases and then decide what to do with them: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 eval :: Query ~ H . ParentDSL State Query ( ChildQuery eff ) ChildSlot Message m eval = case _ of NoOp next - pure next HandleSelect message next - case message of Select . Searched string - pure next Select . Selected item - pure next Select . VisibilityChanged vis - pure next Select . Emit query - pure next Let's take these case-by-case. What should we do when the user has searched something on our dropdown? This is just a simple list of items, so we'll simply ignore their search. We can leave this as pure next . What should we do when the user has selected an item? Ah! This is more interesting. We want to set their item as the currently-selected one, and then we want to remove it from the available items list. Once we've removed it from the available items, we'll update Select with its new items to display and we'll toggle it off. We can use difference from Data . Array to filter out the selected item from the overall list of items. This is a common pattern in Select : the parent holds the immutable list of all possible items, and Select receives some subset of those items at each render. You might use the user's search to filter out items in a typeahead, for example, or only load 50 results at a time into a dropdown. 1 2 3 4 5 6 7 import Data.Array ( difference ) Select . Selected item - do st - H . get _ - H . query unit $ Select . setVisibility Select . Off _ - H . query unit $ Select . replaceItems $ difference st . availableItems [ item ] H . modify _ { selectedItem = Just item } What should we do when the dropdown's visibility has changed? This can often be useful to run validation, but for our dropdown, we don't care what its visibility is. We can leave this as pure next . Finally, what should we do when the child component raises its Emit message? What does this even mean? Emit exists so you can embed your own queries into Select and extend its behavior. Since the message contains one of your own queries, all you have to do is evaluate it: you can call eval recursively to run your query. You can think of Emit as notifying you that the query you embedded is ready to run. 1 2 3 Select . Emit query - do eval query pure next Nice and simple! While you may write all kinds of logic for the other messages raised by Select , you'll always write this same code for the Emit message.","title":"Handling messages from Select"},{"location":"tutorials/dropdown/#conclusion","text":"Congratulations! You have successfully built a keyboard-navigable dropdown using Select . You integrated the library, wrote your own render function, and then augmented it with helper functions from the library. Then, you handled the output messages and sent queries to update the component's state. You've done quite a lot of work! Tip Did you notice anything you would improve about this tutorial or the Select library? I'd love to hear about it! Feel free to reach out on the functional programming Slack or on the PureScript user forum . If you found a bug or would like to make an improvement, please open an issue or pull request on the library.","title":"Conclusion"},{"location":"tutorials/dropdown/#next-steps","text":"This tutorial was a slow, thorough introduction to the Select library. But we've only scratched the surface of what you can do with it. I'd recommend continuing on to the faster-paced and more advanced typeahead tutorial .","title":"Next Steps"},{"location":"tutorials/dropdown/#source-code","text":"If you'd like to use this component as a starting point from which to build your own, feel free to copy/paste the source code below. Full source code for the tutorial 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 module Component where import Prelude import Effect.Aff.Class ( class MonadAff ) import Data.Array ( difference , mapWithIndex ) import Data.Maybe ( Maybe ( .. ), fromMaybe ) import Halogen as H import Halogen.HTML as HH import Halogen.HTML.Events as HE import Halogen.HTML.Properties as HP import Select as Select import Select.Setters as Setters data Query a = HandleSelect ( Select . Message Query String ) a type State = { isOpen :: Boolean , selectedItem :: Maybe String , availableItems :: Array String } type Input = Unit type Message = Void type ChildSlot = Unit type ChildQuery = Select . Query Query String component :: \u2200 m . MonadAff m = H . Component HH . HTML Query Input Message m component = H . parentComponent { initialState , render , eval , receiver : const Nothing } where initialState :: Input - State initialState = const { isOpen : false , selectedItem : Nothing , availableItems : [ Item One , Item Two , Item Three ] } render :: State - H . ParentHTML Query ChildQuery ChildSlot m render parentState = HH . div_ [ HH . h1_ [ HH . text Dropdown ] , HH . slot unit Select . component selectInput ( HE . input HandleSelect ) ] where selectInput :: Select . Input Query String selectInput = { inputType : Select . Toggle , items : parentState . availableItems , initialSearch : Nothing , debounceTime : Nothing , render : dropdown } dropdown :: Select . State String - Select . ComponentHTML Query String dropdown childState = HH . div_ [ HH . button ( Setters . setToggleProps [] ) [ HH . text $ fromMaybe Click me to view some items parentState . selectedItem ] , case childState . visibility of Select . Off - HH . text Select . On - HH . ul ( Setters . setContainerProps [] ) $ mapWithIndex ( \\ ix item - HH . li ( Setters . setItemProps ix $ case Just ix == childState . highlightedIndex of true - [ HP . attr ( HH . AttrName style ) color: red; ] _ - [] ) [ HH . text item ] ) childState . items ] eval :: Query ~ H . ParentDSL State Query ChildQuery ChildSlot Message m eval = case _ of HandleSelect message next - case message of Select . Searched string - pure next Select . Selected item - do st - H . get _ - H . query unit $ Select . setVisibility Select . Off _ - H . query unit $ Select . replaceItems $ difference st . availableItems [ item ] H . modify _ { selectedItem = Just item } pure next Select . VisibilityChanged vis - pure next Select . Emit query - do eval query pure next","title":"Source Code"},{"location":"tutorials/getting-started/","text":"Introduction Halogen is a powerful framework for building PureScript applications. It\u2019s used by several companies, including SlamData and my own company, CitizenNet (a Cond\u00e9 Nast company), among others. The Select library is written for the Halogen framework, so if you don\u2019t know how to use Halogen yet, you ought to start with the Halogen guide . That said, with only passing familiarity with Halogen, you should be able to follow along just fine! Setup Instead of creating a new Halogen project from scratch, we\u2019ll start with a minimal starter template. This template includes the HTML, build scripts, and basic Main.purs file necessary to run your Halogen application. It also includes a component with the bare minimum definitions in place. This component does nothing at all, which is nice because we can easily use it to start building dropdowns, typeaheads, and other components. Info We prefer Yarn over NPM for package management and scripts, but either one will work. Anywhere you see yarn script , you can substitute npm run script instead. Feel free to look at the package.json file if you want to see what these scripts are doing. Installation First, clone the Halogen template project from CitizenNet, install dependencies, and make sure things build properly. If they don\u2019t, please reach out on the Purescript user forum so we can fix it! Next, make sure to install Select : 1 bower i --save purescript-halogen-select Warning The PureScript compiler recently updated to version 0.12 and many core libraries updated at the same time. If you run into version conflicts, please reach out on the Purescript user forum . And that's it! You now have everything you need to complete the tutorials. This is the full set of steps you can follow to get all set up: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Get the CitizenNet starter Halogen project git clone git@github.com:citizennet/purescript-halogen-template.git # Change into the directory and install packages cd purescript-halogen-template yarn # Install a new package: purescript-halogen-select bower i --save purescript-halogen-select # Build the project yarn build # Open the application in the browser open dist/index.html After you complete each step in the tutorial, make sure to rebuild the project and refresh your browser to see your updated component. Helpful tip: Watching for file changes It\u2019s convenient to keep a terminal running which watches for file changes, rebuilds the project, and bundles JavaScript on your behalf. Then, when you make a change to a file, all you have to do is wait a moment and refresh the page to see your updates. When I write PureScript, I usually work with two terminals open. I use the first to write code, and the second to watch those changes and rebuild. I recommend using the same technique as you walk through these tutorials. These three steps are all you need: Open a new terminal and run the watch script Open your editor to a source file Open a new tab in your browser pointed to dist/index.html so you can see the app To test everything is working, try editing src/Component.purs to change the title of the page. The project should automatically rebuild on save. Then, when you refresh the browser, you should see your new text rendered. 1 2 # Watch for changes and rebuild (remember to refresh the page after builds) yarn watch A whirlwind tour of our starter component The project starts off with a minimal Halogen component. As a brief refresher, I'll step through each of the types and functions involved. Info If you are already quite familiar with Halogen, feel free to skip this section entirely. Query Algebra How does a component know what to do? In Halogen, we give names to each computation we'd like a component to run. Computations that can have side effects but don't return anything are colloquially called actions ; those that can have side effects and also return something are called requests . The type that lists out the possible actions and requests for a component is called the component's query algebra . The Halogen guide has a relevant section about query algebras if you'd like to know more. What actions and requests can our starter component perform? By looking at the query algebra, we see just one constructor: 1 2 data Query a = NoOp a All we know so far is that this component can do one thing: evaluate a query called NoOp . We'll see what it does later on when we look at the eval function. State Every component encapsulates some state, described by its State type. You will usually see Halogen components use records to hold state, like this: 1 type State = { on :: Boolean , name :: String } State is the core of your component. Most of the queries you see in Halogen components modify state in some way, and the render function that produces HTML for the component has only the State type as its argument. For our starter component, we don't need any state just yet, so we've simply assigned it the Unit type. When we start building selection components, however, we'll soon create a record to hold our state. 1 type State = Unit Input A component's Input type can be thought of as a container for any information you'd like to pass to the component. It's most commonly used to provide a component with some initial State values via the initialState :: Input - State function. However, it's more powerful than that! Once a Halogen component has been mounted to the DOM, there is only one way to continue sending it new information: its Input type paired with its receiver function. Every time the parent component re-renders, it will send a new Input to the child component. For more information on the Input type, see the Parent and Child Components section of the Halogen guide. Our starter component doesn't need any input, so we'll assign it the Unit type. However, once we build a dropdown or typeahead, we'll probably want to receive the list of items that can be selected as input. 1 type Input = Unit Message How does a component tell its parent when something important has happened? In Halogen, this is accomplished with a Message type. Like the query algebra, this is just a type describing messages that can be raised, containing some information. To actually trigger sending a particular message, you can use the raise function provided by Halogen. When we start building selection components, we'll use messages to notify parent components when items have been selected or removed. Our starter component doesn't need to raise any messages, however, so we've given it the Void type. Why are we using Void when we have no messages? Why use Void instead of Unit for the Message type when it has no constructors? This is common practice in Halogen because of how messages are used by parent components. When your component raises a message, it gets handled by the parent using a function like this: Child . Message - Maybe ( ParentQuery Unit ) If you want to ignore all messages from the child, you could write an implementation like this: Halogen . HTML . Events . input const Nothing However, if the child's message type is Void , then you can use the absurd function from Data.Void : absurd :: Void - a This saves you a bit of typing when you mount a child component in a slot and makes it absolutely unambiguous that there are no messages to handle. It also ensures that if you add a message to the child component later on you'll get a compiler error -- this is a good thing! Compare mounting a child component that uses Unit to represent \"no messages\" vs. using Void : 1 2 3 4 5 6 7 -- It s unclear whether you re ignoring all messages or whether there are -- simply no messages to handle. HH . slot ComponentSlot component unit ( Halogen . HTML . Events . input const Nothing ) -- It s obvious there are no messages, and if that changes (the component adds a -- message) you ll get a nice compile-time error. HH . slot ComponentSlot component unit absurd For more information on messages, see the Parent and Child Components section in the Halogen guide. 1 type Message = Void ChildQuery and ChildSlot Halogen components often have further child components. To maintain type safety when managing multiple child components, Halogen uses a pair of concepts: child queries and child slots . The ChildQuery type lists out each unique type of child component your component has. For each type of child component, you'll add its query type here. The ChildSlot type works like an address book for the various child components. If you only have one child component of any distinct ChildQuery , then you can just use unit . However, if you have multiple children with the same query type, you need some way to distinguish between them. It's common to use custom types or integers for this. See the Multiple Types of Child Component section of the Halogen guide for more details. For now, our component has no children. Once we bring in the Select component we'll update these types. 1 2 type ChildQuery = Const Void type ChildSlot = Unit Component Ah! We can finally create our component. The actual component definition is simple: we call the parentComponent function from Halogen to assert we're creating a component that can have further child components and provide it with the four functions it needs to operate. More on those in a moment! 1 2 3 4 5 6 7 8 9 10 component :: \u2200 m . MonadAff m = H . Component HH . HTML Query Input Message m component = H . parentComponent { initialState , render , eval , receiver : const Nothing } where Next, lets look at those function definitions, defined in the where clause: initialState The initialState function describes how to go from the component's Input type to its State type. In this case, our State type is just Unit , so we'll throw away the input and return unit . 1 2 3 4 5 initialState :: Input - State initialState = const unit -- Could also be written this way: initialState = id render The render function describes how to go from the component's State type to some HTML, where that HTML can include any of the components listed in the ChildQuery type. You'll use plenty of code from these modules when writing render functions: 1 2 3 import Halogen.HTML as HH import Halogen.HTML.Events as HE import Halogen.HTML.Properties as HP We're going to spend a lot of time writing render functions in the following tutorials. You can refer to the Halogen guide's section on rendering for more information. For now we won't render anything to the page, represented by an empty div. 1 2 render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [] eval The eval function describes what to do when one of the queries from the component's query algebra is called. There are various ways a query can be triggered: The parent component can trigger a child component query using the query function A user can trigger a query with an event in HTML, like onClick The eval function can recursively call itself while evaluating a query The eval function is where you get to actually define what all your queries do . Unlike the render function, you can actually perform all kinds of side effects here, like make API calls, update state, trigger queries in child components, raise messages, and more. As usual, our starter component won't do much in its eval . When it receives the NoOp constructor, it will do nothing and return the contents of the query, which in this case will always be unit . 1 2 3 eval :: Query ~ H . ParentDSL State Query ChildQuery ChildSlot Message m eval = case _ of NoOp next - pure next receiver The receiver function describes what to do when a parent component sends in new Input . Its type signature looks like this: 1 receiver :: Input - Maybe ( Query Unit ) Once a Halogen component has been mounted, the only way to send it new input is via its receiver function. When its parent re-renders, it will automatically send the child component's input type again, and it's up to the receiver function to decide what to do with it. This function can either provide a query to call, or Nothing if you'd like to ignore new input. If you elect to provide a query then you unlock all the power available in the eval function and can describe all sorts of things to do on new input, like making API calls or updating state. In our case, we don't care about new input, so we'll ignore the input and return Nothing . 1 2 3 { ... , receiver : const Nothing }","title":"Project setup"},{"location":"tutorials/getting-started/#introduction","text":"Halogen is a powerful framework for building PureScript applications. It\u2019s used by several companies, including SlamData and my own company, CitizenNet (a Cond\u00e9 Nast company), among others. The Select library is written for the Halogen framework, so if you don\u2019t know how to use Halogen yet, you ought to start with the Halogen guide . That said, with only passing familiarity with Halogen, you should be able to follow along just fine!","title":"Introduction"},{"location":"tutorials/getting-started/#setup","text":"Instead of creating a new Halogen project from scratch, we\u2019ll start with a minimal starter template. This template includes the HTML, build scripts, and basic Main.purs file necessary to run your Halogen application. It also includes a component with the bare minimum definitions in place. This component does nothing at all, which is nice because we can easily use it to start building dropdowns, typeaheads, and other components. Info We prefer Yarn over NPM for package management and scripts, but either one will work. Anywhere you see yarn script , you can substitute npm run script instead. Feel free to look at the package.json file if you want to see what these scripts are doing.","title":"Setup"},{"location":"tutorials/getting-started/#installation","text":"First, clone the Halogen template project from CitizenNet, install dependencies, and make sure things build properly. If they don\u2019t, please reach out on the Purescript user forum so we can fix it! Next, make sure to install Select : 1 bower i --save purescript-halogen-select Warning The PureScript compiler recently updated to version 0.12 and many core libraries updated at the same time. If you run into version conflicts, please reach out on the Purescript user forum . And that's it! You now have everything you need to complete the tutorials. This is the full set of steps you can follow to get all set up: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Get the CitizenNet starter Halogen project git clone git@github.com:citizennet/purescript-halogen-template.git # Change into the directory and install packages cd purescript-halogen-template yarn # Install a new package: purescript-halogen-select bower i --save purescript-halogen-select # Build the project yarn build # Open the application in the browser open dist/index.html After you complete each step in the tutorial, make sure to rebuild the project and refresh your browser to see your updated component.","title":"Installation"},{"location":"tutorials/getting-started/#helpful-tip-watching-for-file-changes","text":"It\u2019s convenient to keep a terminal running which watches for file changes, rebuilds the project, and bundles JavaScript on your behalf. Then, when you make a change to a file, all you have to do is wait a moment and refresh the page to see your updates. When I write PureScript, I usually work with two terminals open. I use the first to write code, and the second to watch those changes and rebuild. I recommend using the same technique as you walk through these tutorials. These three steps are all you need: Open a new terminal and run the watch script Open your editor to a source file Open a new tab in your browser pointed to dist/index.html so you can see the app To test everything is working, try editing src/Component.purs to change the title of the page. The project should automatically rebuild on save. Then, when you refresh the browser, you should see your new text rendered. 1 2 # Watch for changes and rebuild (remember to refresh the page after builds) yarn watch","title":"Helpful tip: Watching for file changes"},{"location":"tutorials/getting-started/#a-whirlwind-tour-of-our-starter-component","text":"The project starts off with a minimal Halogen component. As a brief refresher, I'll step through each of the types and functions involved. Info If you are already quite familiar with Halogen, feel free to skip this section entirely.","title":"A whirlwind tour of our starter component"},{"location":"tutorials/getting-started/#query-algebra","text":"How does a component know what to do? In Halogen, we give names to each computation we'd like a component to run. Computations that can have side effects but don't return anything are colloquially called actions ; those that can have side effects and also return something are called requests . The type that lists out the possible actions and requests for a component is called the component's query algebra . The Halogen guide has a relevant section about query algebras if you'd like to know more. What actions and requests can our starter component perform? By looking at the query algebra, we see just one constructor: 1 2 data Query a = NoOp a All we know so far is that this component can do one thing: evaluate a query called NoOp . We'll see what it does later on when we look at the eval function.","title":"Query Algebra"},{"location":"tutorials/getting-started/#state","text":"Every component encapsulates some state, described by its State type. You will usually see Halogen components use records to hold state, like this: 1 type State = { on :: Boolean , name :: String } State is the core of your component. Most of the queries you see in Halogen components modify state in some way, and the render function that produces HTML for the component has only the State type as its argument. For our starter component, we don't need any state just yet, so we've simply assigned it the Unit type. When we start building selection components, however, we'll soon create a record to hold our state. 1 type State = Unit","title":"State"},{"location":"tutorials/getting-started/#input","text":"A component's Input type can be thought of as a container for any information you'd like to pass to the component. It's most commonly used to provide a component with some initial State values via the initialState :: Input - State function. However, it's more powerful than that! Once a Halogen component has been mounted to the DOM, there is only one way to continue sending it new information: its Input type paired with its receiver function. Every time the parent component re-renders, it will send a new Input to the child component. For more information on the Input type, see the Parent and Child Components section of the Halogen guide. Our starter component doesn't need any input, so we'll assign it the Unit type. However, once we build a dropdown or typeahead, we'll probably want to receive the list of items that can be selected as input. 1 type Input = Unit","title":"Input"},{"location":"tutorials/getting-started/#message","text":"How does a component tell its parent when something important has happened? In Halogen, this is accomplished with a Message type. Like the query algebra, this is just a type describing messages that can be raised, containing some information. To actually trigger sending a particular message, you can use the raise function provided by Halogen. When we start building selection components, we'll use messages to notify parent components when items have been selected or removed. Our starter component doesn't need to raise any messages, however, so we've given it the Void type. Why are we using Void when we have no messages? Why use Void instead of Unit for the Message type when it has no constructors? This is common practice in Halogen because of how messages are used by parent components. When your component raises a message, it gets handled by the parent using a function like this: Child . Message - Maybe ( ParentQuery Unit ) If you want to ignore all messages from the child, you could write an implementation like this: Halogen . HTML . Events . input const Nothing However, if the child's message type is Void , then you can use the absurd function from Data.Void : absurd :: Void - a This saves you a bit of typing when you mount a child component in a slot and makes it absolutely unambiguous that there are no messages to handle. It also ensures that if you add a message to the child component later on you'll get a compiler error -- this is a good thing! Compare mounting a child component that uses Unit to represent \"no messages\" vs. using Void : 1 2 3 4 5 6 7 -- It s unclear whether you re ignoring all messages or whether there are -- simply no messages to handle. HH . slot ComponentSlot component unit ( Halogen . HTML . Events . input const Nothing ) -- It s obvious there are no messages, and if that changes (the component adds a -- message) you ll get a nice compile-time error. HH . slot ComponentSlot component unit absurd For more information on messages, see the Parent and Child Components section in the Halogen guide. 1 type Message = Void","title":"Message"},{"location":"tutorials/getting-started/#childquery-and-childslot","text":"Halogen components often have further child components. To maintain type safety when managing multiple child components, Halogen uses a pair of concepts: child queries and child slots . The ChildQuery type lists out each unique type of child component your component has. For each type of child component, you'll add its query type here. The ChildSlot type works like an address book for the various child components. If you only have one child component of any distinct ChildQuery , then you can just use unit . However, if you have multiple children with the same query type, you need some way to distinguish between them. It's common to use custom types or integers for this. See the Multiple Types of Child Component section of the Halogen guide for more details. For now, our component has no children. Once we bring in the Select component we'll update these types. 1 2 type ChildQuery = Const Void type ChildSlot = Unit","title":"ChildQuery and ChildSlot"},{"location":"tutorials/getting-started/#component","text":"Ah! We can finally create our component. The actual component definition is simple: we call the parentComponent function from Halogen to assert we're creating a component that can have further child components and provide it with the four functions it needs to operate. More on those in a moment! 1 2 3 4 5 6 7 8 9 10 component :: \u2200 m . MonadAff m = H . Component HH . HTML Query Input Message m component = H . parentComponent { initialState , render , eval , receiver : const Nothing } where Next, lets look at those function definitions, defined in the where clause:","title":"Component"},{"location":"tutorials/getting-started/#initialstate","text":"The initialState function describes how to go from the component's Input type to its State type. In this case, our State type is just Unit , so we'll throw away the input and return unit . 1 2 3 4 5 initialState :: Input - State initialState = const unit -- Could also be written this way: initialState = id","title":"initialState"},{"location":"tutorials/getting-started/#render","text":"The render function describes how to go from the component's State type to some HTML, where that HTML can include any of the components listed in the ChildQuery type. You'll use plenty of code from these modules when writing render functions: 1 2 3 import Halogen.HTML as HH import Halogen.HTML.Events as HE import Halogen.HTML.Properties as HP We're going to spend a lot of time writing render functions in the following tutorials. You can refer to the Halogen guide's section on rendering for more information. For now we won't render anything to the page, represented by an empty div. 1 2 render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ []","title":"render"},{"location":"tutorials/getting-started/#eval","text":"The eval function describes what to do when one of the queries from the component's query algebra is called. There are various ways a query can be triggered: The parent component can trigger a child component query using the query function A user can trigger a query with an event in HTML, like onClick The eval function can recursively call itself while evaluating a query The eval function is where you get to actually define what all your queries do . Unlike the render function, you can actually perform all kinds of side effects here, like make API calls, update state, trigger queries in child components, raise messages, and more. As usual, our starter component won't do much in its eval . When it receives the NoOp constructor, it will do nothing and return the contents of the query, which in this case will always be unit . 1 2 3 eval :: Query ~ H . ParentDSL State Query ChildQuery ChildSlot Message m eval = case _ of NoOp next - pure next","title":"eval"},{"location":"tutorials/getting-started/#receiver","text":"The receiver function describes what to do when a parent component sends in new Input . Its type signature looks like this: 1 receiver :: Input - Maybe ( Query Unit ) Once a Halogen component has been mounted, the only way to send it new input is via its receiver function. When its parent re-renders, it will automatically send the child component's input type again, and it's up to the receiver function to decide what to do with it. This function can either provide a query to call, or Nothing if you'd like to ignore new input. If you elect to provide a query then you unlock all the power available in the eval function and can describe all sorts of things to do on new input, like making API calls or updating state. In our case, we don't care about new input, so we'll ignore the input and return Nothing . 1 2 3 { ... , receiver : const Nothing }","title":"receiver"},{"location":"tutorials/typeahead/","text":"Let's Build a Typeahead in PureScript! Typeaheads are among the most common selection components you'll build. Most web developers have had to implement at least one of these before and they can be surprisingly difficult to build. Luckily, with Select , implementing a typeahead that fits your custom design takes little more than writing the rendering code and then tweaking it with a helper function or two. In this tutorial we'll build a typeahead with the following features: Users can search Star Wars characters by name; their searches will be debounced automatically and results will be fetched asynchronously. The typeahead should support keyboard-only use: arrow keys should step up and down the items, Enter should select, Escape should close, and so on. The typeahead should manage its own selections, including insertion and removal, and should notify its parent when the selections have changed. If a search returns no results, then there should be an embedded \"fetch data\" button the user can click to force a request with an empty search. It should display within the list of items. Along the way, we'll see how to extend Select 's features by embedding parent queries (we'll use this to embed the \"fetch data\" button in the list). Info This tutorial assumes you've followed the steps in the Project Setup section. While not necessary, this code is tested with those steps in mind. It also assumes familiarity with Halogen and intermediate PureScript experience or that you have already completed the more thorough, beginner-friendly dropdown tutorial . If you need a Halogen refresher, try the official Halogen guide or the whirlwind tour of our starter component. Your code should work at the end of every step. If you run into issues or your code doesn't compile, please come visit us on the PureScript user forum or the #fpchat Slack channel . Basic Setup In this tutorial, we'll build a typeahead component from scratch. You can either follow along using the minimal component from the Project Setup section or start your own. If you didn't follow the project setup, grab the source for our starting component here: Source code for a minimal starting component 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 module Component where import Prelude import Effect.Aff.Class ( class MonadAff ) import Data.Const ( Const ) import Data.Maybe ( Maybe ( .. )) import Halogen as H import Halogen.HTML as HH data Query a = NoOp a type State = Unit type Input = Unit type Message = Void type ChildSlot = Unit type ChildQuery = Const Void component :: \u2200 m . MonadAff m = H . Component HH . HTML Query Input Message m component = H . parentComponent { initialState , render , eval , receiver : const Nothing } where initialState :: Input - State initialState = const unit render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [] eval :: Query ~ H . ParentDSL State Query ChildQuery ChildSlot Message m eval = case _ of NoOp next - pure next Install dependencies The first thing we'll do is make sure we have the libraries we need installed. Our typeahead is going to make API calls on our behalf, decode the response, and keep track of the state of requests using a special RemoteData data type. Let's go ahead and install our dependencies: 1 2 3 4 5 6 7 8 # These should already be installed as part of the project setup bower i --save purescript-halogen purescript-halogen-select purescript-affjax # These are new dependencies bower i --save purescript-argonaut purescript-remotedata # Let s compile the new dependencies to ensure they re available to import yarn build Integrate the component Now let's make sure we have Select ready to go in our component. Import the library: 1 2 import Select as Select import Select.Setters as Setters Next, since Select is going to be a child component, we'll need to update several types and functions. We will: Delete the unnecessary NoOp query and relevant case in eval Add a new query to handle messages emitted by Select Update our ChildQuery type synonym to contain Select 's query type Update the type signatures for eval and render with the new ChildQuery Add a new case to eval for our new HandleSelect query Tip This tutorial doesn't explain things like child queries, slots, inputs, rendering, Free , eval functions, or other crucial Halogen knowledge. If you feel lost, I'd recommend checking out the dropdown tutorial before continuing. Of course, we won't be prepared to handle messages or use Select 's queries without knowing what they are. Let's start with the query type for the Select component, QueryF : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- | - `o`: The query type of the component that will mount this component in a child slot. -- | This allows you to embed your own queries into the `Select` component. -- | - `item`: Your custom item type. It can be a simple type like `String`, or something -- | complex like `CalendarItem StartDate EndDate (Maybe Disabled)`. data QueryF o item a = Search String a | Highlight Target a | Select Int a | CaptureRef ET . Event a | Focus Boolean a | Key KE . KeyboardEvent a | PreventClick ME . MouseEvent a | SetVisibility Visibility a | GetVisibility ( Visibility - a ) | ReplaceItems ( Array item ) a | Raise ( o Unit ) a | Receive ( Input o item ) a Already we're faced with an interesting decision: how should we fill in the type variables that Select expects? o represents the type of queries that can be embedded in the component. You should fill this in with your parent component's query type. If you follow Halogen convention and name your type Query , then filling this variable in will produce Select . Query Query item eff . If you take a look at where this variable is used, you'll see it shows up in the Select component's Raise and Receive queries. The Raise query is a wrapper that you can use to embed your query into the render function you provide to the component. The Receive query leverages Select 's Input type, which includes that render function. I'll have a lot more to say about embedding your own query type into Select later on. The second type argument is more interesting. Select allows you to provide any type as your selectable \"item\". While in this tutorial we're going to stick with strings you could very well make a significantly more information-rich type. Writing useful item types Any time you need to render some items differently than others, or you need different logic for when one item is selected vs. another, you should encode that information in the item type. For example, at CitizenNet, our calendar component has an item type like this: 1 data CalendarItem = CalendarItem SelectedStatus DisabledStatus Boundary Range Date These custom types give us everything we need to know to render various dates and handle them when selected. For example, if you want some items to be selectable and others to be disabled, you could create an item type like this: 1 2 3 4 5 6 data Item = Selectable String | Disabled String renderItem ix ( Selectable str ) = HH . li ( Setters . setItemProps ix [ ] ) [ HH . text str ] renderItem _ ( Disabled str ) = HH . li_ [ HH . text str ] With all this information in mind, let's go ahead and make those changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 data Query a = HandleSelect ( Select . Message Query String ) a type ChildSlot = Unit type ChildQuery = Select . Query Query String component = ... render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [] eval :: Query ~ H . ParentDSL State Query ChildQuery ChildSlot Message m eval = case _ of -- We ll just stub this out for the time being. HandleSelect message next - pure next Next, we'll actually mount the Select component. We have everything except for the component's Input type so far, so we'll fill that in and leave the input as a type hole. 1 2 3 4 5 6 import Halogen.HTML.Events as HE render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [ HH . slot unit Select . component ? input ( HE . input HandleSelect ) ] With that out of the way, we can turn to the component's input type. Here's what we're required to fill in, as per the Select module documentation : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- | Text-driven inputs will operate like a normal search-driven selection component. -- | Toggle-driven inputs will capture key streams and debounce in reverse (only notify -- | about searches when time has expired). data InputType = TextInput | Toggle -- | The component s input type, which includes the component s render function. This -- | render function can also be used to share data with the parent component, as every -- | time the parent re-renders, the render function will refresh in `Select`. type Input o item = { inputType :: InputType , items :: Array item , initialSearch :: Maybe String , debounceTime :: Maybe Milliseconds , render :: State item - ComponentHTML o item } Let's look at these one-by-one: We're using an input field in the DOM, so we'll use the TextInput type to drive the component. We don't have any items yet (they'll be fetched via the Star Wars API), so we'll provide an empty array. We don't want there to be an initial search; we'll wait for the user to type something. However, if at any point we want to fill in text in the input field (for example, set the text to the full selection when the user selects something), we can use this field to accomplish that. We're making API calls every time the user performs a search, so we'll set a reasonable debounce time of a few hundred milliseconds. Ah, the big issue: we need to write a render function and pass it in to the component. We don't have one yet, so we'll stub this out with a simple empty div . Let's write that input record now: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import Data.Time.Duration ( Milliseconds ( .. )) render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [ HH . slot unit Select . component selectInput ( HE . input HandleSelect ) ] selectInput :: Select . Input Query String selectInput = { inputType : Select . TextInput , items : [] , initialSearch : Nothing , debounceTime : Just $ Milliseconds 250.0 , render : \\ _ - HH . div_ [ HH . text Not implemented ] } All right! We've fully integrated the Select component. It's a little tedious to integrate the component the first time you do it, but it soon becomes second nature. At this point, we're ready to start writing our typeahead. Now would be a good time to verify that this component is rendering properly. Compile the project and point your browser to dist/index.html . You should see text rendering from within Select . A minimal typeahead Let's take a step back now that we have Select integrated. We are building a typeahead that will fetch some data asynchronously when the user makes a search. It needs to maintain a list of items that can be selected, and a list of items that have already been selected. The user should only be able to select any item once, so these two lists should have no shared items. We'd like the typeahead to handle all the data fetching and selections behind the scenes, and only notify the parent component when the selections have been updated. With this information in mind, we can step through the key data types in our Halogen component and ensure they accurately capture the features we want. Note In the dropdown tutorial, we started by writing a render function and only later worried about state, queries, messages, and so on. However, I usually like to work in the other direction. We already know the behaviors and data we need to manage, and we don't need to render anything to implement them, though we'll certainly use our rendered component for testing. Instead, we'll work through the major data types in our component and only once those are completed will we write some minimal rendering code. It might feel a little strange to spend so much time on data without once touching the HTML, but by the time we reach our rendering function it will naturally extend from the data. State From our requirements, we know we'll need some information: A list of items that can be selected by the user A list of items that have already been selected, and which can be removed The user's last search, so we can use it to fetch new data from the Star Wars API It'll also be nice to have some extra information purely for rendering purposes, like: An indicator as to whether the menu should be displayed or not An indicator as to which item the user has focused, so we can highlight it We have access to two distinct State types when we use Select : the parent component state, which we own, and the Select component's state, which we can read and write. There's no point in duplicating information between the two if we can help it. But we have access to even more information: messages output by the component. Sometimes we can simply rely on the contents of these messages to take action without ever storing the result in state. Let's take a quick look at what Select provides (take a look at the module documentation for more details): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type State item = { inputType :: InputType , search :: String , debounceTime :: Milliseconds , debouncer :: Maybe Debouncer , inputElement :: Maybe HTMLElement , items :: Array item , visibility :: Visibility , highlightedIndex :: Maybe Int , lastIndex :: Int } data Message o item = Searched String | Selected item | VisibilityChanged Visibility | Emit ( o Unit ) It looks like we already have the list of selectable items stored in Select , so we don't need that in our component state. We're fetching new items via an external API, so after each new search we can simply pass the new items straight down. We also have the user's search stored in State and also raised as a message every time the debouncer runs out. We don't really care about every keystroke the user types, so we'll rely on the Searched message for this information. We have our two pieces of rendering information, too, with the visibility and highlightedIndex fields. In fact, it looks like the only thing we have to store in our State is the list of selecetions! That keeps things simple. 1 type State = { selections :: Array String } Tip Select doesn't manage any selections on your behalf. What should happen when an item gets selected, after all? In some cases, you might want to stick it into a \"selected\" list and remove it from the list of available options. In others, you might want it to be selectable multiple times. Or you might want to just apply a highlight, like in a calendar picker. Rather than force you to fill out a configuration record, Select defers the decision to you. This is OK, but I'd like some more information. We're fetching data asynchronously, right? That means that requests could possibly fail, or they might be in progress for a long time, or perhaps they might never get triggered in the first place. Ideally our typeahead could render differently depending on these states. If we don't keep track of our requests in State , we won't have any of this information available for rendering. It's the same idea as using an information-rich custom item type to add nuance to your rendering code. Luckily, there already exists a lovely package named purescript-remotedata that supplies us with a data type we can use to model each of these states: 1 2 3 4 5 data RemoteData e a = NotAsked | Loading | Failure e | Success a So while it's not strictly necessary to maintain a list of items in our state, we'll leverage RemoteData to have a more useful state type. 1 2 3 4 5 6 7 8 9 10 type State = { items :: RemoteData String ( Array String ) , selections :: Array String } initialState :: Input - State initialState = const { items : NotAsked , selections : [] } Query Now that we've got a usable State type, let's turn to our queries. Queries are the computations available to the component, so they're the place where we ought to think about what the typeahead should do , rather than just how it should render. Just like State , when we write our own Query type on top of Select , we should consider what is already available in the component. As usual, we'll turn to the module documentation to look at our available queries. I'd recommend scrolling through the available functions to get a glimpse of what Select offers, but we'll skip to the main points here. Select is going to manage all the keyboard events, text input, debouncing, moving the highlighted index, and so on. On top of that, we'll need to add some extra functionality: the ability to remove items that have already been selected, and the ability to fetch new items when the user performs a search. We'll at least need two queries to handle these two features. Luckily, though, we already have a query available for when a new search has been performed: our HandleSelect query tied to the Select . Searched message! That means we really only need one new query: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 data Query a = HandleSelect ( Select . Message Query String ) a | Remove String a eval :: Query ~ H . ParentDSL State Query ChildQuery ChildSlot Message m eval = case _ of HandleSelect message next - case message of Select . Searched str - pure next Select . Selected item - pure next Select . VisibilityChanged vis - pure next Select . Emit query - pure next Remove item next - pure next What do we want to happen in each of these queries? Let's work from the bottom to the top. Remove When the user clicks on an item that is already selected, we want to remove it from the selected list. We also want to re-insert it into the available items in Select . It's easy enough to accomplish this: 1 2 3 4 5 6 7 Remove item next - do H . modify \\ st - st { selections = filter ( _ /= item ) st . selections } st - H . get _ - H . query unit $ Select . replaceItems $ difference ( withDefault [] st . items ) st . selections pure next Emit What should we do when we get the Emit message? This is returning our own query to us so we can run it, so we can recursively call eval with the query. You'll use this pattern every time you implement a new component with Select : 1 Select . Emit query - eval query * pure next VisibilityChange What about when the visibility changes? We don't actually care about this one, so we'll ignore it. It's useful for validation, if we were to implement that. Selected What about when an item is selected? This one is like the inverse of our Remove query. We want to remove the item from the available items and add it to the list of selections. 1 2 3 4 5 6 7 Select . Selected item - do H . modify \\ st - st { selections = item : st . selections } st - H . get _ - H . query unit $ Select . replaceItems $ difference ( withDefault [] st . items ) st . selections pure next Searched We can finally consider what to do when the user performs a search. We won't do any fancy filtering on our own; we're going to punt that responsibility to an external API. Still, now we have to write the code to fetch that data. Our function will hit the Star Wars API, decode the result into an array of strings, and then return them. In the case of failure, we'll return an error message. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import Data.Argonaut ( Json , decodeJson , ( .? )) import Network.HTTP.Affjax as AX import Network.HTTP.Affjax.Response as Response fetchItems :: String - Aff ( Either String ( Array String )) fetchItems str = do res - _ . response $ ( AX . get $ Response . json $ https://swapi.co/api/people/?search= str ) pure $ do obj - decodeJson res arr - obj .? results traverse ( decodeJson = flip ( .? ) name ) arr Now that we have this helper function, we can handle new searches that users perform. First, we'll put our typeahead into the Loading state to represent an ongoing request. Then, we'll empty out the old items in Select to avoid out-of-sync data. Then, we'll fetch and decode our items, convert the result from Either to RemoteData , and finally set it on State . Once our new items have been set, we can use the result to update Select just like we did when we handled new selections or removals. 1 2 3 4 5 6 7 8 9 10 Select . Searched string - do H . modify _ { items = Loading } _ - H . query unit $ Select . replaceItems [] newItems - H . liftAff ( fetchItems string ) H . modify _ { items = fromEither newItems } st - H . get _ - H . query unit $ Select . replaceItems $ difference ( withDefault [] st . items ) st . selections That's it! Our typeahead has all the logic necessary to function as required. All that's left to do is actually write the render function. Rendering We have all the state and behavior necessary to run a working typeahead. Now, let's write the render function. When you write a render function for a Select component, keep in mind that the function is going to be run by the child component. You can see this right away from the type signature of the render function that Select expects: 1 myRenderFunction :: Select . State item - Select . ComponentHTML o item In our case, we've already specialized our parent query, item, and effects, so the type signature is actually this: 1 2 3 myRenderFunction :: Select . State String - Select . ComponentHTML Query String Tip When you write a component with Select , you'll usually want access to the parent component's state and query algebra. This is what makes the pattern powerful: you can use any values from your state in the render function you provide to Select , and you can embed any queries from your query algebra, too. Most of the time developers will stay in scope with the parent component by writing the Select render function within a where clause. However, you could also write a render function outside the parent component so long as it takes the parent state as an argument, like this: 1 2 3 4 selectRenderFunction :: Parent . State - Select . State String - Select . ComponentHTML Parent . Query String Then you can write this render function anywhere you'd like while retaining access to the parent's state and query algebra. Select will not accept this function as-is, however; you'll need to apply it to the parent state before sending the function in as input: 1 selectInput = { ... , render : selectRenderFunction parentState , ... } Since you write the render function to pass to Select, you retain full control of the design and most of the structure of your HTML. All that Select expects from you is that you apply the three helper functions from Setters : setItemProps on each item that can be selected setContainerProps on the parent HTML element of all the items setInputProps on the text input For this reason, I usually break my component's render function into three helpers. Let's go ahead and write our render function for the typeahead. Our overall function is going to take the parent state, the Select state, and output the Select component HTML type: 1 2 3 4 5 typeahead :: State - Select . State String - Select . ComponentHTML Query String typeahead parentState childState = ... Let's write this function from top to bottom. We want our typeahead to have the list of selected items above the input field, then the input field, then the list of available items (if there are any). Ultimately, with helper functions, we'd like to write this: 1 2 3 4 5 typeahead parentState childState = HH . div_ [ renderSelections , renderInput , renderContainer ] where ... Let's start with the first one: renderSelections . This function will leverage only the parent state, which contains the selections, and won't use anything from Select . Tip In fact you don't need to render the selections inside Select at all -- you could render the selections first, and then mount the Select component below. We use this approach for our own typeaheads at CitizenNet. However, embedding the selections into the Select component allows me to show off how embedding parent queries works and it's an equally viable design, so that's the approach taken here. We're just going to render an unordered list of items that have been selected. If the user clicks on one of them, then we'll remove the selection. We can remove items with the Remove query that we wrote a little earlier. But wait! Since this is rendering inside of Select , it needs to have the Select type signature. If we try to write this function it will fail: 1 2 3 4 5 6 7 8 9 10 11 -- The items that have already been selected and can be removed renderSelections :: Select . ComponentHTML Query String renderSelections = HH . ul_ ( st . selections # ( \\ item - HH . li [ HE . onClick $ HE . input_ $ Remove item ] [ HH . text item ] ) ) The compiler gives us this error: 1 2 3 4 5 6 7 8 9 10 11 12 Error found in module Component Could not match type Free ( QueryF t2 t3 t4 ) with type Query while trying to match type Free ( QueryF t2 t3 t4 ) Unit with type Query Unit The problem is that we're using a parent query in the body of a render function for a component with an entirely different query algebra. If we tried to run this in Select it would have no idea what to do with the !#hs Remove query! Instead, we need to embed this query. To embed a parent query into Select , we'll use a query from Select called Raise and a message called Emit . We've already seen Emit before -- when we receive this message, we simply evaluate the query within it. That's how we can evaluate queries like Remove in the parent component even though the event actually happened inside its child, the Select component. Raise is a new one: this query exists to wrap parent queries so they can be embedded. That's why Select carries around your parent query in its type signature everywhere! As a rule of thumb, any time you need to extend functionality in Select , you will: Write the new functionality as a query in your parent component and accompanying eval handler. This handler can freely trigger queries and updates in Select , or modify parent state that is then used in the Select render function. This is quite powerful! Ensure that you are handling output messages from Select , and specifically that when you receive the Emit message that you recursively evaluate it as was demonstrated earlier in the tutorial. Place the query in Select 's render function wrapped in Select . raise , triggered by whatever event you would like. Let's see all of this in action: 1 2 3 4 5 6 7 8 9 renderSelections = HH . ul_ ( st . selections # ( \\ item - HH . li [ HE . onClick $ Select . always $ Select . raise $ Remove item unit ] [ HH . text item ] ) ) Now we can use this inside Select and it will behave just as if it had been written in the parent all along! Let's move on to the input field. This field needs to be controlled by Select and must have the setInputProps helper used on its array of properties: 1 2 -- The text input field that will capture key events renderInput = HH . input ( Setters . setInputProps [] ) That's it! Now we have all the key events wired up for you. You could embed your own queries here, or add CSS, or whatever you want and the behavior will still work just fine. Warning Select will append the properties it needs to the input field, including onMouseDown , onValueInput , and so on. Unfortunately there can only be one of these handlers in the list of properties, so if you already placed an onValueInput handler it will be overwritten by Select . If you need to trigger some new functionality from the same handler that Select is using, then you can always write a custom setInputProps function for yourself that routes the event to your own query and the relevant Select query. Take a look at the module documentation for Select.Setters to see how. Next, let's render the actual items. Remember that we need to use setContainerProps on the containing element (in this case HH . ul ) and setItemProps on each item. This code is a little trickier. We only want to show the items when the user has focused the typeahead and hide them otherwise. If there are no items, then we want to embed a \"Refresh Data\" button with some custom functionality. And we want to use Select 's information about which item is highlighted to apply a little CSS. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 -- The parent element holding the items renderContainer = case childState . visibility of Select . Off - HH . text Select . On - HH . ul ( Setters . setContainerProps [] ) ( case null childState . items of false - mapWithIndex renderItem childState . items _ - [ HH . li [ HE . onClick $ Select . always $ Select . raise $ H . action $ HandleSelect ( Select . Searched ) ] [ HH . text Fetch data again. ] ] ) -- Each individual item, which will receive an index and the item renderItem ix item = HH . li ( Setters . setItemProps ix -- If this is the highlighted item, then apply CSS $ case Just ix == childState . highlightedIndex of true - [ HP . attr ( HH . AttrName style ) color: red; ] _ - [] ) [ HH . text item ] To recap, we'll use these helper functions in the overall render function we're passing to Select : 1 2 3 4 5 6 7 typeahead parentState childState = HH . div_ [ renderSelections , renderInput , renderContainer ] where renderSelections = ... renderInput = ... renderContainer = ... If you got a little lost in all the rendering code here, don't worry: the full code is contained at the end of the tutorial. Conclusion That's it! We now have a fully-functioning typeahead that will fetch data remotely after debouncing a user's search, and if there are no results, will allow the user to refresh the data. Notably, several parts of this typeahead are not supported in any way by Select , but we've been able to freely extend the component to make this possible. Next Steps Now that you're able to build a typeahead with Select you know everything you need to build more complex components like date pickers and image pickers. The next tutorial in the series, Let's build a date picker , is currently a work in progress. Tip Did you notice anything you would improve about this tutorial or the Select library? I'd love to hear about it! Feel free to reach out on the functional programming Slack or on the PureScript user forum . If you found a bug or would like to make an improvement, please open an issue or pull request on the library. Source Code If you'd like to use this component as a starting point from which to build your own, feel free to copy/paste the source code below. Full source code for the tutorial 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 module Component where import Prelude import Effect.Aff ( Aff ) import Effect.Aff.Class ( class MonadAff ) import Data.Argonaut ( Json , decodeJson , ( .? )) import Data.Array ( difference , filter , mapWithIndex , null , ( : )) import Data.Either ( Either ) import Data.Maybe ( Maybe ( .. )) import Data.Time.Duration ( Milliseconds ( .. )) import Data.Traversable ( traverse ) import Halogen as H import Halogen.HTML as HH import Halogen.HTML.Events as HE import Halogen.HTML.Properties ( attr ) as HP import Network.HTTP.Affjax as AX import Network.HTTP.Affjax.Response as Response import Network.RemoteData ( RemoteData ( .. ), fromEither , withDefault ) import Select as Select import Select.Setters as Setters data Query a = HandleSelect ( Select . Message Query String ) a | Remove String a type State = { items :: RemoteData String ( Array String ) , selections :: Array String } type Input = Unit type Message = Void type ChildSlot = Unit type ChildQuery = Select . Query Query String component :: \u2200 m . MonadAff m = H . Component HH . HTML Query Input Message m component = H . parentComponent { initialState , render , eval , receiver : const Nothing } where initialState :: Input - State initialState = const { items : NotAsked , selections : [] } fetchItems :: String - Aff ( Either String ( Array String )) fetchItems str = do res - _ . response $ ( AX . get $ Response . json $ https://swapi.co/api/people/?search= str ) pure $ do obj - decodeJson res arr - obj .? results traverse ( decodeJson = flip ( .? ) name ) arr render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [ HH . slot unit Select . component selectInput ( HE . input HandleSelect ) ] where selectInput :: Select . Input Query String selectInput = { inputType : Select . TextInput , items : [] , initialSearch : Nothing , debounceTime : Just $ Milliseconds 250.0 , render : typeahead st } typeahead :: State - Select . State String - Select . ComponentHTML Query String typeahead parentState childState = HH . div_ [ renderSelections , renderInput , renderContainer ] where -- The items that have already been selected and can be removed renderSelections = HH . ul_ ( st . selections # ( \\ item - HH . li [ HE . onClick $ Select . always $ Select . raise $ Remove item unit ] [ HH . text item ] ) ) -- The text input field that will capture key events renderInput = HH . input ( Setters . setInputProps [] ) -- The parent element holding the items container renderContainer = case childState . visibility of Select . Off - HH . text Select . On - HH . ul ( Setters . setContainerProps [] ) ( case null childState . items of false - mapWithIndex renderItem childState . items _ - [ HH . li [ HE . onClick $ Select . always $ Select . raise $ HandleSelect ( Select . Searched ) unit ] [ HH . text Fetch data again. ] ] ) -- Each individual item, which will receive an index and the item renderItem ix item = HH . li ( Setters . setItemProps ix -- If this is the highlighted item, then apply CSS $ case Just ix == childState . highlightedIndex of true - [ HP . attr ( HH . AttrName style ) color: red; ] _ - [] ) [ HH . text item ] eval :: Query ~ H . ParentDSL State Query ChildQuery ChildSlot Message m eval = case _ of Remove item next - do H . modify \\ st - st { selections = filter ( _ /= item ) st . selections } st - H . get _ - H . query unit $ Select . replaceItems $ difference ( withDefault [] st . items ) st . selections pure next HandleSelect message next - case message of Select . Searched string - do H . modify _ { items = Loading } _ - H . query unit $ Select . replaceItems [] newItems - H . liftAff ( fetchItems string ) H . modify _ { items = fromEither newItems } st - H . get _ - H . query unit $ Select . replaceItems $ difference ( withDefault [] st . items ) st . selections pure next Select . Selected item - do H . modify \\ st - st { selections = item : st . selections } st - H . get _ - H . query unit $ Select . replaceItems $ difference ( withDefault [] st . items ) st . selections pure next Select . VisibilityChanged vis - pure next Select . Emit query - do eval query pure next","title":"Build a typeahead"},{"location":"tutorials/typeahead/#lets-build-a-typeahead-in-purescript","text":"Typeaheads are among the most common selection components you'll build. Most web developers have had to implement at least one of these before and they can be surprisingly difficult to build. Luckily, with Select , implementing a typeahead that fits your custom design takes little more than writing the rendering code and then tweaking it with a helper function or two. In this tutorial we'll build a typeahead with the following features: Users can search Star Wars characters by name; their searches will be debounced automatically and results will be fetched asynchronously. The typeahead should support keyboard-only use: arrow keys should step up and down the items, Enter should select, Escape should close, and so on. The typeahead should manage its own selections, including insertion and removal, and should notify its parent when the selections have changed. If a search returns no results, then there should be an embedded \"fetch data\" button the user can click to force a request with an empty search. It should display within the list of items. Along the way, we'll see how to extend Select 's features by embedding parent queries (we'll use this to embed the \"fetch data\" button in the list). Info This tutorial assumes you've followed the steps in the Project Setup section. While not necessary, this code is tested with those steps in mind. It also assumes familiarity with Halogen and intermediate PureScript experience or that you have already completed the more thorough, beginner-friendly dropdown tutorial . If you need a Halogen refresher, try the official Halogen guide or the whirlwind tour of our starter component. Your code should work at the end of every step. If you run into issues or your code doesn't compile, please come visit us on the PureScript user forum or the #fpchat Slack channel .","title":"Let's Build a Typeahead in PureScript!"},{"location":"tutorials/typeahead/#basic-setup","text":"In this tutorial, we'll build a typeahead component from scratch. You can either follow along using the minimal component from the Project Setup section or start your own. If you didn't follow the project setup, grab the source for our starting component here: Source code for a minimal starting component 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 module Component where import Prelude import Effect.Aff.Class ( class MonadAff ) import Data.Const ( Const ) import Data.Maybe ( Maybe ( .. )) import Halogen as H import Halogen.HTML as HH data Query a = NoOp a type State = Unit type Input = Unit type Message = Void type ChildSlot = Unit type ChildQuery = Const Void component :: \u2200 m . MonadAff m = H . Component HH . HTML Query Input Message m component = H . parentComponent { initialState , render , eval , receiver : const Nothing } where initialState :: Input - State initialState = const unit render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [] eval :: Query ~ H . ParentDSL State Query ChildQuery ChildSlot Message m eval = case _ of NoOp next - pure next","title":"Basic Setup"},{"location":"tutorials/typeahead/#install-dependencies","text":"The first thing we'll do is make sure we have the libraries we need installed. Our typeahead is going to make API calls on our behalf, decode the response, and keep track of the state of requests using a special RemoteData data type. Let's go ahead and install our dependencies: 1 2 3 4 5 6 7 8 # These should already be installed as part of the project setup bower i --save purescript-halogen purescript-halogen-select purescript-affjax # These are new dependencies bower i --save purescript-argonaut purescript-remotedata # Let s compile the new dependencies to ensure they re available to import yarn build","title":"Install dependencies"},{"location":"tutorials/typeahead/#integrate-the-component","text":"Now let's make sure we have Select ready to go in our component. Import the library: 1 2 import Select as Select import Select.Setters as Setters Next, since Select is going to be a child component, we'll need to update several types and functions. We will: Delete the unnecessary NoOp query and relevant case in eval Add a new query to handle messages emitted by Select Update our ChildQuery type synonym to contain Select 's query type Update the type signatures for eval and render with the new ChildQuery Add a new case to eval for our new HandleSelect query Tip This tutorial doesn't explain things like child queries, slots, inputs, rendering, Free , eval functions, or other crucial Halogen knowledge. If you feel lost, I'd recommend checking out the dropdown tutorial before continuing. Of course, we won't be prepared to handle messages or use Select 's queries without knowing what they are. Let's start with the query type for the Select component, QueryF : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- | - `o`: The query type of the component that will mount this component in a child slot. -- | This allows you to embed your own queries into the `Select` component. -- | - `item`: Your custom item type. It can be a simple type like `String`, or something -- | complex like `CalendarItem StartDate EndDate (Maybe Disabled)`. data QueryF o item a = Search String a | Highlight Target a | Select Int a | CaptureRef ET . Event a | Focus Boolean a | Key KE . KeyboardEvent a | PreventClick ME . MouseEvent a | SetVisibility Visibility a | GetVisibility ( Visibility - a ) | ReplaceItems ( Array item ) a | Raise ( o Unit ) a | Receive ( Input o item ) a Already we're faced with an interesting decision: how should we fill in the type variables that Select expects? o represents the type of queries that can be embedded in the component. You should fill this in with your parent component's query type. If you follow Halogen convention and name your type Query , then filling this variable in will produce Select . Query Query item eff . If you take a look at where this variable is used, you'll see it shows up in the Select component's Raise and Receive queries. The Raise query is a wrapper that you can use to embed your query into the render function you provide to the component. The Receive query leverages Select 's Input type, which includes that render function. I'll have a lot more to say about embedding your own query type into Select later on. The second type argument is more interesting. Select allows you to provide any type as your selectable \"item\". While in this tutorial we're going to stick with strings you could very well make a significantly more information-rich type. Writing useful item types Any time you need to render some items differently than others, or you need different logic for when one item is selected vs. another, you should encode that information in the item type. For example, at CitizenNet, our calendar component has an item type like this: 1 data CalendarItem = CalendarItem SelectedStatus DisabledStatus Boundary Range Date These custom types give us everything we need to know to render various dates and handle them when selected. For example, if you want some items to be selectable and others to be disabled, you could create an item type like this: 1 2 3 4 5 6 data Item = Selectable String | Disabled String renderItem ix ( Selectable str ) = HH . li ( Setters . setItemProps ix [ ] ) [ HH . text str ] renderItem _ ( Disabled str ) = HH . li_ [ HH . text str ] With all this information in mind, let's go ahead and make those changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 data Query a = HandleSelect ( Select . Message Query String ) a type ChildSlot = Unit type ChildQuery = Select . Query Query String component = ... render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [] eval :: Query ~ H . ParentDSL State Query ChildQuery ChildSlot Message m eval = case _ of -- We ll just stub this out for the time being. HandleSelect message next - pure next Next, we'll actually mount the Select component. We have everything except for the component's Input type so far, so we'll fill that in and leave the input as a type hole. 1 2 3 4 5 6 import Halogen.HTML.Events as HE render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [ HH . slot unit Select . component ? input ( HE . input HandleSelect ) ] With that out of the way, we can turn to the component's input type. Here's what we're required to fill in, as per the Select module documentation : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- | Text-driven inputs will operate like a normal search-driven selection component. -- | Toggle-driven inputs will capture key streams and debounce in reverse (only notify -- | about searches when time has expired). data InputType = TextInput | Toggle -- | The component s input type, which includes the component s render function. This -- | render function can also be used to share data with the parent component, as every -- | time the parent re-renders, the render function will refresh in `Select`. type Input o item = { inputType :: InputType , items :: Array item , initialSearch :: Maybe String , debounceTime :: Maybe Milliseconds , render :: State item - ComponentHTML o item } Let's look at these one-by-one: We're using an input field in the DOM, so we'll use the TextInput type to drive the component. We don't have any items yet (they'll be fetched via the Star Wars API), so we'll provide an empty array. We don't want there to be an initial search; we'll wait for the user to type something. However, if at any point we want to fill in text in the input field (for example, set the text to the full selection when the user selects something), we can use this field to accomplish that. We're making API calls every time the user performs a search, so we'll set a reasonable debounce time of a few hundred milliseconds. Ah, the big issue: we need to write a render function and pass it in to the component. We don't have one yet, so we'll stub this out with a simple empty div . Let's write that input record now: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import Data.Time.Duration ( Milliseconds ( .. )) render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [ HH . slot unit Select . component selectInput ( HE . input HandleSelect ) ] selectInput :: Select . Input Query String selectInput = { inputType : Select . TextInput , items : [] , initialSearch : Nothing , debounceTime : Just $ Milliseconds 250.0 , render : \\ _ - HH . div_ [ HH . text Not implemented ] } All right! We've fully integrated the Select component. It's a little tedious to integrate the component the first time you do it, but it soon becomes second nature. At this point, we're ready to start writing our typeahead. Now would be a good time to verify that this component is rendering properly. Compile the project and point your browser to dist/index.html . You should see text rendering from within Select .","title":"Integrate the component"},{"location":"tutorials/typeahead/#a-minimal-typeahead","text":"Let's take a step back now that we have Select integrated. We are building a typeahead that will fetch some data asynchronously when the user makes a search. It needs to maintain a list of items that can be selected, and a list of items that have already been selected. The user should only be able to select any item once, so these two lists should have no shared items. We'd like the typeahead to handle all the data fetching and selections behind the scenes, and only notify the parent component when the selections have been updated. With this information in mind, we can step through the key data types in our Halogen component and ensure they accurately capture the features we want. Note In the dropdown tutorial, we started by writing a render function and only later worried about state, queries, messages, and so on. However, I usually like to work in the other direction. We already know the behaviors and data we need to manage, and we don't need to render anything to implement them, though we'll certainly use our rendered component for testing. Instead, we'll work through the major data types in our component and only once those are completed will we write some minimal rendering code. It might feel a little strange to spend so much time on data without once touching the HTML, but by the time we reach our rendering function it will naturally extend from the data.","title":"A minimal typeahead"},{"location":"tutorials/typeahead/#state","text":"From our requirements, we know we'll need some information: A list of items that can be selected by the user A list of items that have already been selected, and which can be removed The user's last search, so we can use it to fetch new data from the Star Wars API It'll also be nice to have some extra information purely for rendering purposes, like: An indicator as to whether the menu should be displayed or not An indicator as to which item the user has focused, so we can highlight it We have access to two distinct State types when we use Select : the parent component state, which we own, and the Select component's state, which we can read and write. There's no point in duplicating information between the two if we can help it. But we have access to even more information: messages output by the component. Sometimes we can simply rely on the contents of these messages to take action without ever storing the result in state. Let's take a quick look at what Select provides (take a look at the module documentation for more details): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type State item = { inputType :: InputType , search :: String , debounceTime :: Milliseconds , debouncer :: Maybe Debouncer , inputElement :: Maybe HTMLElement , items :: Array item , visibility :: Visibility , highlightedIndex :: Maybe Int , lastIndex :: Int } data Message o item = Searched String | Selected item | VisibilityChanged Visibility | Emit ( o Unit ) It looks like we already have the list of selectable items stored in Select , so we don't need that in our component state. We're fetching new items via an external API, so after each new search we can simply pass the new items straight down. We also have the user's search stored in State and also raised as a message every time the debouncer runs out. We don't really care about every keystroke the user types, so we'll rely on the Searched message for this information. We have our two pieces of rendering information, too, with the visibility and highlightedIndex fields. In fact, it looks like the only thing we have to store in our State is the list of selecetions! That keeps things simple. 1 type State = { selections :: Array String } Tip Select doesn't manage any selections on your behalf. What should happen when an item gets selected, after all? In some cases, you might want to stick it into a \"selected\" list and remove it from the list of available options. In others, you might want it to be selectable multiple times. Or you might want to just apply a highlight, like in a calendar picker. Rather than force you to fill out a configuration record, Select defers the decision to you. This is OK, but I'd like some more information. We're fetching data asynchronously, right? That means that requests could possibly fail, or they might be in progress for a long time, or perhaps they might never get triggered in the first place. Ideally our typeahead could render differently depending on these states. If we don't keep track of our requests in State , we won't have any of this information available for rendering. It's the same idea as using an information-rich custom item type to add nuance to your rendering code. Luckily, there already exists a lovely package named purescript-remotedata that supplies us with a data type we can use to model each of these states: 1 2 3 4 5 data RemoteData e a = NotAsked | Loading | Failure e | Success a So while it's not strictly necessary to maintain a list of items in our state, we'll leverage RemoteData to have a more useful state type. 1 2 3 4 5 6 7 8 9 10 type State = { items :: RemoteData String ( Array String ) , selections :: Array String } initialState :: Input - State initialState = const { items : NotAsked , selections : [] }","title":"State"},{"location":"tutorials/typeahead/#query","text":"Now that we've got a usable State type, let's turn to our queries. Queries are the computations available to the component, so they're the place where we ought to think about what the typeahead should do , rather than just how it should render. Just like State , when we write our own Query type on top of Select , we should consider what is already available in the component. As usual, we'll turn to the module documentation to look at our available queries. I'd recommend scrolling through the available functions to get a glimpse of what Select offers, but we'll skip to the main points here. Select is going to manage all the keyboard events, text input, debouncing, moving the highlighted index, and so on. On top of that, we'll need to add some extra functionality: the ability to remove items that have already been selected, and the ability to fetch new items when the user performs a search. We'll at least need two queries to handle these two features. Luckily, though, we already have a query available for when a new search has been performed: our HandleSelect query tied to the Select . Searched message! That means we really only need one new query: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 data Query a = HandleSelect ( Select . Message Query String ) a | Remove String a eval :: Query ~ H . ParentDSL State Query ChildQuery ChildSlot Message m eval = case _ of HandleSelect message next - case message of Select . Searched str - pure next Select . Selected item - pure next Select . VisibilityChanged vis - pure next Select . Emit query - pure next Remove item next - pure next What do we want to happen in each of these queries? Let's work from the bottom to the top.","title":"Query"},{"location":"tutorials/typeahead/#remove","text":"When the user clicks on an item that is already selected, we want to remove it from the selected list. We also want to re-insert it into the available items in Select . It's easy enough to accomplish this: 1 2 3 4 5 6 7 Remove item next - do H . modify \\ st - st { selections = filter ( _ /= item ) st . selections } st - H . get _ - H . query unit $ Select . replaceItems $ difference ( withDefault [] st . items ) st . selections pure next","title":"Remove"},{"location":"tutorials/typeahead/#emit","text":"What should we do when we get the Emit message? This is returning our own query to us so we can run it, so we can recursively call eval with the query. You'll use this pattern every time you implement a new component with Select : 1 Select . Emit query - eval query * pure next","title":"Emit"},{"location":"tutorials/typeahead/#visibilitychange","text":"What about when the visibility changes? We don't actually care about this one, so we'll ignore it. It's useful for validation, if we were to implement that.","title":"VisibilityChange"},{"location":"tutorials/typeahead/#selected","text":"What about when an item is selected? This one is like the inverse of our Remove query. We want to remove the item from the available items and add it to the list of selections. 1 2 3 4 5 6 7 Select . Selected item - do H . modify \\ st - st { selections = item : st . selections } st - H . get _ - H . query unit $ Select . replaceItems $ difference ( withDefault [] st . items ) st . selections pure next","title":"Selected"},{"location":"tutorials/typeahead/#searched","text":"We can finally consider what to do when the user performs a search. We won't do any fancy filtering on our own; we're going to punt that responsibility to an external API. Still, now we have to write the code to fetch that data. Our function will hit the Star Wars API, decode the result into an array of strings, and then return them. In the case of failure, we'll return an error message. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import Data.Argonaut ( Json , decodeJson , ( .? )) import Network.HTTP.Affjax as AX import Network.HTTP.Affjax.Response as Response fetchItems :: String - Aff ( Either String ( Array String )) fetchItems str = do res - _ . response $ ( AX . get $ Response . json $ https://swapi.co/api/people/?search= str ) pure $ do obj - decodeJson res arr - obj .? results traverse ( decodeJson = flip ( .? ) name ) arr Now that we have this helper function, we can handle new searches that users perform. First, we'll put our typeahead into the Loading state to represent an ongoing request. Then, we'll empty out the old items in Select to avoid out-of-sync data. Then, we'll fetch and decode our items, convert the result from Either to RemoteData , and finally set it on State . Once our new items have been set, we can use the result to update Select just like we did when we handled new selections or removals. 1 2 3 4 5 6 7 8 9 10 Select . Searched string - do H . modify _ { items = Loading } _ - H . query unit $ Select . replaceItems [] newItems - H . liftAff ( fetchItems string ) H . modify _ { items = fromEither newItems } st - H . get _ - H . query unit $ Select . replaceItems $ difference ( withDefault [] st . items ) st . selections That's it! Our typeahead has all the logic necessary to function as required. All that's left to do is actually write the render function.","title":"Searched"},{"location":"tutorials/typeahead/#rendering","text":"We have all the state and behavior necessary to run a working typeahead. Now, let's write the render function. When you write a render function for a Select component, keep in mind that the function is going to be run by the child component. You can see this right away from the type signature of the render function that Select expects: 1 myRenderFunction :: Select . State item - Select . ComponentHTML o item In our case, we've already specialized our parent query, item, and effects, so the type signature is actually this: 1 2 3 myRenderFunction :: Select . State String - Select . ComponentHTML Query String Tip When you write a component with Select , you'll usually want access to the parent component's state and query algebra. This is what makes the pattern powerful: you can use any values from your state in the render function you provide to Select , and you can embed any queries from your query algebra, too. Most of the time developers will stay in scope with the parent component by writing the Select render function within a where clause. However, you could also write a render function outside the parent component so long as it takes the parent state as an argument, like this: 1 2 3 4 selectRenderFunction :: Parent . State - Select . State String - Select . ComponentHTML Parent . Query String Then you can write this render function anywhere you'd like while retaining access to the parent's state and query algebra. Select will not accept this function as-is, however; you'll need to apply it to the parent state before sending the function in as input: 1 selectInput = { ... , render : selectRenderFunction parentState , ... } Since you write the render function to pass to Select, you retain full control of the design and most of the structure of your HTML. All that Select expects from you is that you apply the three helper functions from Setters : setItemProps on each item that can be selected setContainerProps on the parent HTML element of all the items setInputProps on the text input For this reason, I usually break my component's render function into three helpers. Let's go ahead and write our render function for the typeahead. Our overall function is going to take the parent state, the Select state, and output the Select component HTML type: 1 2 3 4 5 typeahead :: State - Select . State String - Select . ComponentHTML Query String typeahead parentState childState = ... Let's write this function from top to bottom. We want our typeahead to have the list of selected items above the input field, then the input field, then the list of available items (if there are any). Ultimately, with helper functions, we'd like to write this: 1 2 3 4 5 typeahead parentState childState = HH . div_ [ renderSelections , renderInput , renderContainer ] where ... Let's start with the first one: renderSelections . This function will leverage only the parent state, which contains the selections, and won't use anything from Select . Tip In fact you don't need to render the selections inside Select at all -- you could render the selections first, and then mount the Select component below. We use this approach for our own typeaheads at CitizenNet. However, embedding the selections into the Select component allows me to show off how embedding parent queries works and it's an equally viable design, so that's the approach taken here. We're just going to render an unordered list of items that have been selected. If the user clicks on one of them, then we'll remove the selection. We can remove items with the Remove query that we wrote a little earlier. But wait! Since this is rendering inside of Select , it needs to have the Select type signature. If we try to write this function it will fail: 1 2 3 4 5 6 7 8 9 10 11 -- The items that have already been selected and can be removed renderSelections :: Select . ComponentHTML Query String renderSelections = HH . ul_ ( st . selections # ( \\ item - HH . li [ HE . onClick $ HE . input_ $ Remove item ] [ HH . text item ] ) ) The compiler gives us this error: 1 2 3 4 5 6 7 8 9 10 11 12 Error found in module Component Could not match type Free ( QueryF t2 t3 t4 ) with type Query while trying to match type Free ( QueryF t2 t3 t4 ) Unit with type Query Unit The problem is that we're using a parent query in the body of a render function for a component with an entirely different query algebra. If we tried to run this in Select it would have no idea what to do with the !#hs Remove query! Instead, we need to embed this query. To embed a parent query into Select , we'll use a query from Select called Raise and a message called Emit . We've already seen Emit before -- when we receive this message, we simply evaluate the query within it. That's how we can evaluate queries like Remove in the parent component even though the event actually happened inside its child, the Select component. Raise is a new one: this query exists to wrap parent queries so they can be embedded. That's why Select carries around your parent query in its type signature everywhere! As a rule of thumb, any time you need to extend functionality in Select , you will: Write the new functionality as a query in your parent component and accompanying eval handler. This handler can freely trigger queries and updates in Select , or modify parent state that is then used in the Select render function. This is quite powerful! Ensure that you are handling output messages from Select , and specifically that when you receive the Emit message that you recursively evaluate it as was demonstrated earlier in the tutorial. Place the query in Select 's render function wrapped in Select . raise , triggered by whatever event you would like. Let's see all of this in action: 1 2 3 4 5 6 7 8 9 renderSelections = HH . ul_ ( st . selections # ( \\ item - HH . li [ HE . onClick $ Select . always $ Select . raise $ Remove item unit ] [ HH . text item ] ) ) Now we can use this inside Select and it will behave just as if it had been written in the parent all along! Let's move on to the input field. This field needs to be controlled by Select and must have the setInputProps helper used on its array of properties: 1 2 -- The text input field that will capture key events renderInput = HH . input ( Setters . setInputProps [] ) That's it! Now we have all the key events wired up for you. You could embed your own queries here, or add CSS, or whatever you want and the behavior will still work just fine. Warning Select will append the properties it needs to the input field, including onMouseDown , onValueInput , and so on. Unfortunately there can only be one of these handlers in the list of properties, so if you already placed an onValueInput handler it will be overwritten by Select . If you need to trigger some new functionality from the same handler that Select is using, then you can always write a custom setInputProps function for yourself that routes the event to your own query and the relevant Select query. Take a look at the module documentation for Select.Setters to see how. Next, let's render the actual items. Remember that we need to use setContainerProps on the containing element (in this case HH . ul ) and setItemProps on each item. This code is a little trickier. We only want to show the items when the user has focused the typeahead and hide them otherwise. If there are no items, then we want to embed a \"Refresh Data\" button with some custom functionality. And we want to use Select 's information about which item is highlighted to apply a little CSS. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 -- The parent element holding the items renderContainer = case childState . visibility of Select . Off - HH . text Select . On - HH . ul ( Setters . setContainerProps [] ) ( case null childState . items of false - mapWithIndex renderItem childState . items _ - [ HH . li [ HE . onClick $ Select . always $ Select . raise $ H . action $ HandleSelect ( Select . Searched ) ] [ HH . text Fetch data again. ] ] ) -- Each individual item, which will receive an index and the item renderItem ix item = HH . li ( Setters . setItemProps ix -- If this is the highlighted item, then apply CSS $ case Just ix == childState . highlightedIndex of true - [ HP . attr ( HH . AttrName style ) color: red; ] _ - [] ) [ HH . text item ] To recap, we'll use these helper functions in the overall render function we're passing to Select : 1 2 3 4 5 6 7 typeahead parentState childState = HH . div_ [ renderSelections , renderInput , renderContainer ] where renderSelections = ... renderInput = ... renderContainer = ... If you got a little lost in all the rendering code here, don't worry: the full code is contained at the end of the tutorial.","title":"Rendering"},{"location":"tutorials/typeahead/#conclusion","text":"That's it! We now have a fully-functioning typeahead that will fetch data remotely after debouncing a user's search, and if there are no results, will allow the user to refresh the data. Notably, several parts of this typeahead are not supported in any way by Select , but we've been able to freely extend the component to make this possible.","title":"Conclusion"},{"location":"tutorials/typeahead/#next-steps","text":"Now that you're able to build a typeahead with Select you know everything you need to build more complex components like date pickers and image pickers. The next tutorial in the series, Let's build a date picker , is currently a work in progress. Tip Did you notice anything you would improve about this tutorial or the Select library? I'd love to hear about it! Feel free to reach out on the functional programming Slack or on the PureScript user forum . If you found a bug or would like to make an improvement, please open an issue or pull request on the library.","title":"Next Steps"},{"location":"tutorials/typeahead/#source-code","text":"If you'd like to use this component as a starting point from which to build your own, feel free to copy/paste the source code below. Full source code for the tutorial 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 module Component where import Prelude import Effect.Aff ( Aff ) import Effect.Aff.Class ( class MonadAff ) import Data.Argonaut ( Json , decodeJson , ( .? )) import Data.Array ( difference , filter , mapWithIndex , null , ( : )) import Data.Either ( Either ) import Data.Maybe ( Maybe ( .. )) import Data.Time.Duration ( Milliseconds ( .. )) import Data.Traversable ( traverse ) import Halogen as H import Halogen.HTML as HH import Halogen.HTML.Events as HE import Halogen.HTML.Properties ( attr ) as HP import Network.HTTP.Affjax as AX import Network.HTTP.Affjax.Response as Response import Network.RemoteData ( RemoteData ( .. ), fromEither , withDefault ) import Select as Select import Select.Setters as Setters data Query a = HandleSelect ( Select . Message Query String ) a | Remove String a type State = { items :: RemoteData String ( Array String ) , selections :: Array String } type Input = Unit type Message = Void type ChildSlot = Unit type ChildQuery = Select . Query Query String component :: \u2200 m . MonadAff m = H . Component HH . HTML Query Input Message m component = H . parentComponent { initialState , render , eval , receiver : const Nothing } where initialState :: Input - State initialState = const { items : NotAsked , selections : [] } fetchItems :: String - Aff ( Either String ( Array String )) fetchItems str = do res - _ . response $ ( AX . get $ Response . json $ https://swapi.co/api/people/?search= str ) pure $ do obj - decodeJson res arr - obj .? results traverse ( decodeJson = flip ( .? ) name ) arr render :: State - H . ParentHTML Query ChildQuery ChildSlot m render st = HH . div_ [ HH . slot unit Select . component selectInput ( HE . input HandleSelect ) ] where selectInput :: Select . Input Query String selectInput = { inputType : Select . TextInput , items : [] , initialSearch : Nothing , debounceTime : Just $ Milliseconds 250.0 , render : typeahead st } typeahead :: State - Select . State String - Select . ComponentHTML Query String typeahead parentState childState = HH . div_ [ renderSelections , renderInput , renderContainer ] where -- The items that have already been selected and can be removed renderSelections = HH . ul_ ( st . selections # ( \\ item - HH . li [ HE . onClick $ Select . always $ Select . raise $ Remove item unit ] [ HH . text item ] ) ) -- The text input field that will capture key events renderInput = HH . input ( Setters . setInputProps [] ) -- The parent element holding the items container renderContainer = case childState . visibility of Select . Off - HH . text Select . On - HH . ul ( Setters . setContainerProps [] ) ( case null childState . items of false - mapWithIndex renderItem childState . items _ - [ HH . li [ HE . onClick $ Select . always $ Select . raise $ HandleSelect ( Select . Searched ) unit ] [ HH . text Fetch data again. ] ] ) -- Each individual item, which will receive an index and the item renderItem ix item = HH . li ( Setters . setItemProps ix -- If this is the highlighted item, then apply CSS $ case Just ix == childState . highlightedIndex of true - [ HP . attr ( HH . AttrName style ) color: red; ] _ - [] ) [ HH . text item ] eval :: Query ~ H . ParentDSL State Query ChildQuery ChildSlot Message m eval = case _ of Remove item next - do H . modify \\ st - st { selections = filter ( _ /= item ) st . selections } st - H . get _ - H . query unit $ Select . replaceItems $ difference ( withDefault [] st . items ) st . selections pure next HandleSelect message next - case message of Select . Searched string - do H . modify _ { items = Loading } _ - H . query unit $ Select . replaceItems [] newItems - H . liftAff ( fetchItems string ) H . modify _ { items = fromEither newItems } st - H . get _ - H . query unit $ Select . replaceItems $ difference ( withDefault [] st . items ) st . selections pure next Select . Selected item - do H . modify \\ st - st { selections = item : st . selections } st - H . get _ - H . query unit $ Select . replaceItems $ difference ( withDefault [] st . items ) st . selections pure next Select . VisibilityChanged vis - pure next Select . Emit query - do eval query pure next","title":"Source Code"}]}
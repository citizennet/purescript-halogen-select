# Understanding Free Monad Queries

Most of the time Halogen queries look like this:
```hs
data QueryF (… other type arguments omitted …) a
  = ...
  | SetVisibility Visibility a
  | GetVisibility (Visibility -> a)
```
(where `#!hs QueryF` is used directly as the Halogen query functor)

This library takes a slightly different approach: the query functor is actually `#!hs Control.Monad.Free.Free QueryF`, the [free monad](https://pursuit.purescript.org/packages/purescript-free/4.2.0/docs/Control.Monad.Free) generated by the query functor.

This allows queries the full power of monadic (and applicative) composition: sequencing effects, determining control flow based on previous results, and my favorite: doing nothing (`#!hs pure unit`).

We now define smart query constructors for this Free pattern like so:
```hs
-- | Set the container visibility (`On` or `Off`).
setVisibility :: ∀ o item eff. Visibility -> Query o item eff Unit
setVisibility v = liftF (SetVisibility v unit)

-- | Get the container visibility (`On` or `Off`). Most useful when sequenced
-- | with other actions.
getVisibility :: ∀ o item eff. Query o item eff Visibility
getVisibility = liftF (GetVisibility id)
```

## Different patterns
In the simple cases, the helpers Halogen use to work with raw query constructors are folded into the smart Free query constructors already: `#!hs H.action (SetVisibility On)` becomes simply `#!hs setVisiblity On`, and similarly `#!hs H.request GetVisibility` is just `#!hs getVisibility`. This is because these patterns are typically present already smart constructors: `#!hs setVisibility` returns `#!hs Free QueryF Unit`, since it is an action, and `#!hs getVisibility` returns `#!hs Free QueryF Visibility`, since it requests the visibility. This allows for easy composition in `#!hs do` notation:
```hs
toggleVisibility = do
  vis <- getVisibility
  setVisibility (not vis)
```
C’est très facile!

Event handlers look a little different. This is one example:
```hs
HE.onMouseDown \ev -> Just do
    Select.preventClick ev
    Select.select index
    when doBlur Select.triggerBlur
```
(Of course you may return `#!hs Nothing` if you so wish, but its effect is just like `#!hs pure unit` now.)

If you do not need access to the argument `#!hs ev`, `#!hs Select.always` provides a simple shortcut for `#!hs const <<< Just`:
```hs
HE.onMouseOver $ Select.always $ Select.highlight (Index index)
```

## Returning non-unit values
Use `#!hs map` or `#!hs <$` or `#!hs pure` to return other types of values from a query. So, instead of something like this:
```hs
H.subscribe $ eventSource' someEventSource
  \value -> Just (SetVisibility value H.Listening)
```
Use
```hs
H.subscribe $ eventSource' someEventSource
  \value -> Just $ setVisibility value $> H.Listening
```
or
```hs
H.subscribe $ eventSource' someEventSource
  \value -> Just do
    setVisibility value
    pure H.Listening
```

!!! note ""
    Many thanks to [Nicholas Scheel](https://github.com/MonoidMusician) for providing the implementation of `QueryF` and the documentation above.
